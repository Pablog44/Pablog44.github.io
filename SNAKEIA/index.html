<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <!-- Viewport para móviles: evita zoom y ajusta escala -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Neuro Snake 3D - Mobile Battle</title>
    <style>
        /* ESTILOS GENERALES */
        body { margin: 0; overflow: hidden; background: #050505; font-family: 'Courier New', Courier, monospace; color: #fff; user-select: none; -webkit-user-select: none; touch-action: none; }
        
        /* PANEL DE CONTROL (UI) */
        #ui {
            position: absolute; top: 10px; left: 10px; z-index: 10;
            background: rgba(0, 10, 20, 0.9); padding: 15px; border: 1px solid #0ff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.1);
            border-radius: 8px; width: 300px;
            transition: transform 0.3s ease;
        }
        /* Botón para minimizar UI en móvil */
        #toggle-ui { display: none; position: absolute; top: 5px; right: 5px; background: transparent; border: 1px solid #0ff; color: #0ff; font-size: 10px; width: 30px; padding: 5px; }

        h1 { margin: 0 0 10px 0; font-size: 20px; color: #0ff; text-shadow: 0 0 10px #0ff; text-align: center; letter-spacing: 2px; }
        .stat { display: flex; justify-content: space-between; margin-bottom: 5px; font-size: 12px; border-bottom: 1px solid #333; padding-bottom: 2px; }
        .highlight-green { color: #00ff55; font-weight: bold; }
        
        select, button {
            width: 100%; padding: 10px; margin-top: 5px;
            background: #000; color: #0ff; border: 1px solid #0ff;
            cursor: pointer; font-weight: bold; text-transform: uppercase;
            transition: all 0.2s; font-size: 12px;
        }
        button:hover { background: #0ff; color: #000; box-shadow: 0 0 10px #0ff; }
        button:active { background: #fff; }
        button:disabled { border-color: #444; color: #444; cursor: not-allowed; background: #111; box-shadow: none; }

        /* CONTROLES MÓVILES (D-PAD) */
        #mobile-controls {
            display: none; /* Se activa con media query */
            position: absolute; bottom: 20px; right: 20px; z-index: 20;
            width: 150px; height: 150px;
        }
        .d-btn {
            position: absolute; width: 50px; height: 50px;
            background: rgba(0, 255, 255, 0.1); border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 10px; pointer-events: auto;
            display: flex; align-items: center; justify-content: center;
            font-size: 24px; color: rgba(0, 255, 255, 0.8); user-select: none;
        }
        .d-btn:active { background: rgba(0, 255, 255, 0.4); color: #fff; }
        #btn-up { top: 0; left: 50px; }
        #btn-down { bottom: 0; left: 50px; }
        #btn-left { top: 50px; left: 0; }
        #btn-right { top: 50px; right: 0; }

        /* MARCADOR */
        #scoreboard {
            position: absolute; top: 10px; left: 50%; transform: translateX(-50%); z-index: 9;
            background: rgba(0, 0, 0, 0.6); border: 1px solid #fff;
            padding: 5px 20px; border-radius: 20px;
            display: none; gap: 20px; font-size: 16px; font-weight: bold;
        }
        .score-h { color: #0088ff; }
        .score-ai { color: #ff0055; }

        /* PANTALLAS MENSAJE */
        #msg-overlay {
            position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%);
            font-size: 20px; color: white; text-shadow: 0 0 10px red;
            display: none; pointer-events: none; z-index: 20; font-weight: bold;
            background: rgba(0,0,0,0.6); padding: 10px; border-radius: 5px; text-align: center;
        }

        #game-over-modal {
            display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0, 5, 10, 0.95); border: 2px solid #ff0055;
            padding: 20px; text-align: center; z-index: 100;
            box-shadow: 0 0 50px rgba(255, 0, 85, 0.3);
            border-radius: 10px; width: 80%; max-width: 300px;
        }
        #game-over-modal h2 { margin-top: 0; color: #fff; }

        #canvas-container { width: 100vw; height: 100vh; }

        /* RESPONSIVE MEDIA QUERIES */
        @media (max-width: 768px) {
            #mobile-controls { display: block; } /* Mostrar botones en móvil */
            #ui { width: 90%; max-width: 300px; padding: 10px; transform-origin: top left; }
            #ui.minimized { transform: scale(0.0); opacity: 0; pointer-events: none; }
            #toggle-ui { display: block; }
            h1 { font-size: 18px; }
            #scoreboard { top: 60px; font-size: 14px; width: 100%; justify-content: center; border: none; background: transparent; text-shadow: 0 0 2px black;}
        }
    </style>
    <!-- Three.js -->
    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
</head>
<body>

<!-- UI PANEL -->
<div id="ui">
    <button id="toggle-ui" onclick="toggleUI()">X</button>
    <h1>NEURO BATTLE AI</h1>
    
    <div class="stat"><span>Gen:</span> <span id="gen-display">0</span></div>
    <div class="stat"><span>Max Fitness:</span> <span id="best-fitness-display">0</span></div>
    <div class="stat"><span class="highlight-green">Récord:</span> <span id="record-display">0</span></div>
    <div class="stat"><span>Estado:</span> <span id="status-display" style="color: yellow">Esperando...</span></div>
    
    <select id="gridSize">
        <option value="10">Mapa Pequeño (10x10)</option>
        <option value="15" selected>Mapa Mediano (15x15)</option>
        <option value="20">Mapa Grande (20x20)</option>
    </select>

    <button id="btn-train" onclick="startTraining()">1. Entrenar (Battle Mode)</button>
    <button id="btn-watch" onclick="startWatch()" disabled>2. Ver IA Sola</button>
    <button id="btn-play" onclick="startVersus()" disabled>3. Jugar vs IA</button>
</div>

<!-- BOTÓN FLOTANTE PARA MOSTRAR MENÚ SI ESTÁ OCULTO -->
<button id="show-menu-btn" onclick="toggleUI()" style="position:absolute; top:10px; left:10px; width:40px; height:40px; z-index:5; display:none;">☰</button>

<!-- CONTROLES MÓVIL -->
<div id="mobile-controls">
    <div class="d-btn" id="btn-up" onclick="handleMobileInput(0)">▲</div>
    <div class="d-btn" id="btn-left" onclick="handleMobileInput(2)">◀</div>
    <div class="d-btn" id="btn-right" onclick="handleMobileInput(3)">▶</div>
    <div class="d-btn" id="btn-down" onclick="handleMobileInput(1)">▼</div>
</div>

<div id="scoreboard">
    <span class="score-h">TÚ: <span id="score-h-val">0</span></span>
    <span class="score-ai">IA: <span id="score-ai-val">0</span></span>
</div>

<div id="msg-overlay">ESPECTADOR<br><span style="font-size:14px">(Has muerto)</span></div>

<div id="game-over-modal">
    <h2>FIN PARTIDA</h2>
    <div class="final-score">TU SCORE: <span class="final-val" id="final-h" style="color:#0088ff">0</span></div>
    <div class="final-score">IA SCORE: <span class="final-val" id="final-ai" style="color:#ff0055">0</span></div>
    <div id="winner-text" style="margin:15px 0; font-weight:bold; font-size:18px;"></div>
    <button onclick="closeModal()">Cerrar</button>
</div>

<div id="canvas-container"></div>

<script>
// --------------------------------------------------------------------
// 1. RED NEURONAL & SERPIENTE
// --------------------------------------------------------------------
class NeuralNetwork {
    constructor(inputNodes, hiddenNodes, outputNodes) {
        this.inputNodes = inputNodes;
        this.hiddenNodes = hiddenNodes;
        this.outputNodes = outputNodes;
        this.weightsIH = new Float32Array(hiddenNodes * inputNodes).map(() => Math.random() * 2 - 1);
        this.weightsHO = new Float32Array(outputNodes * hiddenNodes).map(() => Math.random() * 2 - 1);
        this.biasH = new Float32Array(hiddenNodes).map(() => Math.random() * 2 - 1);
        this.biasO = new Float32Array(outputNodes).map(() => Math.random() * 2 - 1);
    }
    predict(inputs) {
        let hidden = new Float32Array(this.hiddenNodes);
        for (let i = 0; i < this.hiddenNodes; i++) {
            let sum = 0;
            for (let j = 0; j < this.inputNodes; j++) sum += inputs[j] * this.weightsIH[i * this.inputNodes + j];
            hidden[i] = Math.max(0, sum + this.biasH[i]); // ReLU
        }
        let output = new Float32Array(this.outputNodes);
        for (let i = 0; i < this.outputNodes; i++) {
            let sum = 0;
            for (let j = 0; j < this.hiddenNodes; j++) sum += hidden[j] * this.weightsHO[i * this.hiddenNodes + j];
            output[i] = sum + this.biasO[i];
        }
        return output;
    }
    clone() {
        let c = new NeuralNetwork(this.inputNodes, this.hiddenNodes, this.outputNodes);
        c.weightsIH.set(this.weightsIH); c.weightsHO.set(this.weightsHO);
        c.biasH.set(this.biasH); c.biasO.set(this.biasO);
        return c;
    }
    mutate(rate) {
        const mut = v => (Math.random() < rate) ? v + (Math.random() * 0.5 - 0.25) : v;
        this.weightsIH = this.weightsIH.map(mut); this.weightsHO = this.weightsHO.map(mut);
        this.biasH = this.biasH.map(mut); this.biasO = this.biasO.map(mut);
    }
}

const UP=0, DOWN=1, LEFT=2, RIGHT=3;

class Snake {
    constructor(gridSize, brain=null, isHuman=false) {
        this.gridSize = gridSize;
        this.body = []; 
        this.direction = -1; 
        this.isDead = false;
        this.score = 0;
        this.lifeLeft = 200; 
        this.lifetime = 0;
        this.isHuman = isHuman;
        this.brain = brain || new NeuralNetwork(24, 16, 4); 
        this.fitness = 0;
    }
    reset(x, y) {
        this.body = [{x, y}];
        this.direction = -1;
        this.isDead = false;
        this.lifeLeft = 200;
        this.score = 0;
        this.lifetime = 0;
    }
    think(food, enemies=[]) {
        if(this.isHuman) return;
        let head = this.body[0];
        let inputs = [];
        let dirs = [{x:0,y:-1},{x:1,y:-1},{x:1,y:0},{x:1,y:1},{x:0,y:1},{x:-1,y:1},{x:-1,y:0},{x:-1,y:-1}];
        for(let d of dirs) inputs = inputs.concat(this.look(d, head, food, enemies));
        
        let out = this.brain.predict(inputs);
        let max = -Infinity, choice = 0;
        for(let i=0; i<4; i++) if(out[i]>max){ max=out[i]; choice=i; }

        const cur = this.direction;
        // Evitar giro de 180
        if(choice===UP && cur!==DOWN) this.direction=UP;
        else if(choice===DOWN && cur!==UP) this.direction=DOWN;
        else if(choice===LEFT && cur!==RIGHT) this.direction=LEFT;
        else if(choice===RIGHT && cur!==LEFT) this.direction=RIGHT;
    }
    look(dir, head, food, enemies) {
        let res = [0,0,0]; // Food, Body/Enemy, Wall
        let x = head.x, y = head.y, dist = 0;
        x += dir.x; y += dir.y; dist++;
        let foundFood=false, foundBody=false;
        while(x>=0 && x<this.gridSize && y>=0 && y<this.gridSize) {
            if(!foundFood && x===food.x && y===food.y) { res[0]=1; foundFood=true; }
            if(!foundBody) {
                // Cuerpo propio
                if(this.body.some(p=>p.x===x && p.y===y)) { res[1]=1/dist; foundBody=true; }
                // Enemigos
                else if(enemies.some(e=>e.x===x && e.y===y)) { res[1]=1/dist; foundBody=true; }
            }
            x+=dir.x; y+=dir.y; dist++;
        }
        res[2] = 1/dist; // Wall
        return res;
    }
    update(food, enemies=[]) {
        if(this.isDead) return false;
        this.lifeLeft--; this.lifetime++;
        if(this.lifeLeft<=0 && !this.isHuman) { this.isDead=true; return false; }

        let head = {...this.body[0]};
        if(this.direction===UP) head.y--;
        else if(this.direction===DOWN) head.y++;
        else if(this.direction===LEFT) head.x--;
        else if(this.direction===RIGHT) head.x++;
        else return false;

        // Choque pared
        if(head.x<0 || head.x>=this.gridSize || head.y<0 || head.y>=this.gridSize) { this.isDead=true; return false; }
        // Choque propio
        for(let p of this.body) if(head.x===p.x && head.y===p.y){ this.isDead=true; return false; }
        // Choque enemigos (Colisión = Muerte)
        for(let p of enemies) if(head.x===p.x && head.y===p.y){ this.isDead=true; return false; }

        this.body.unshift(head);
        if(head.x===food.x && head.y===food.y) {
            this.score++;
            this.lifeLeft = Math.min(this.lifeLeft+100, 500);
            return true;
        } else {
            this.body.pop();
            return false;
        }
    }
}

// --------------------------------------------------------------------
// 2. ESCENA 3D (Three.js)
// --------------------------------------------------------------------
const scene = new THREE.Scene(); scene.background = new THREE.Color(0x020205);
const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
document.getElementById('canvas-container').appendChild(renderer.domElement);

const light = new THREE.DirectionalLight(0xffffff, 1.5); light.position.set(10,30,20); light.castShadow=true; scene.add(light);
scene.add(new THREE.AmbientLight(0x404040, 1.5));

const matAI = new THREE.MeshPhongMaterial({color:0xff0055, emissive:0x440022});
const matHuman = new THREE.MeshPhongMaterial({color:0x0088ff, emissive:0x002288});
const matEnemy = new THREE.MeshPhongMaterial({color:0xffaa00, emissive:0x884400}); // Color segunda IA entrenando
const matDead = new THREE.MeshLambertMaterial({color:0x555555});
const matFood = new THREE.MeshPhongMaterial({color:0x00ff55, emissive:0x004400});
const geoCube = new THREE.BoxGeometry(0.9,0.9,0.9);
const geoFood = new THREE.SphereGeometry(0.45,12,12);

let foodMesh = new THREE.Mesh(geoFood, matFood); scene.add(foodMesh);
let meshes = [];
let gridSize = 15;

function setupScene(size) {
    // Limpiar
    while(scene.children.length>0) scene.remove(scene.children[0]);
    scene.add(light); scene.add(new THREE.AmbientLight(0x404040)); scene.add(foodMesh);

    // Grid Piso
    const plane = new THREE.Mesh(new THREE.PlaneGeometry(size,size), new THREE.MeshLambertMaterial({color:0x111111}));
    plane.rotation.x = -Math.PI/2; plane.position.set(size/2-0.5, -0.55, size/2-0.5); scene.add(plane);
    
    const grid = new THREE.GridHelper(size, size, 0x00ffff, 0x222222);
    grid.position.set(size/2-0.5, -0.5, size/2-0.5); scene.add(grid);

    // Ajustar cámara para móvil: un poco más lejos
    let camDist = size * 1.5;
    if(window.innerWidth < 768) camDist = size * 2.2; // Más lejos en móvil
    camera.position.set(size/2, camDist, size*1.1);
    camera.lookAt(size/2, 0, size/2);
}

function draw(snakes, food) {
    meshes.forEach(m=>scene.remove(m)); meshes = [];
    snakes.forEach((s, index) => {
        if(!s) return;
        let mat;
        if(s.isDead) mat = matDead;
        else if(s.isHuman) mat = matHuman;
        else mat = (index === 0 && mode==='TRAINING') ? matAI : (index===1 && mode==='TRAINING' ? matEnemy : matAI); // Diferenciar AIs en training (opcional, pero útil visualmente)
        
        s.body.forEach(p => {
            let m = new THREE.Mesh(geoCube, mat);
            m.position.set(p.x, 0, p.y);
            scene.add(m); meshes.push(m);
        });
    });
    foodMesh.position.set(food.x, 0, food.y);
    renderer.render(scene, camera);
}

// --------------------------------------------------------------------
// 3. LÓGICA JUEGO & ENTRENAMIENTO ADVERSARIO
// --------------------------------------------------------------------
let POP_SIZE = 100; // Par para 1vs1
let pop = [];
let bestBrain = null;
let record = 0;
let generation = 0;
let mode = 'IDLE';
let gameTimer, trainTimer;

let human = null, ai = null, food = {x:0,y:0};
let isSpectator = false;

function initPop() {
    pop = [];
    for(let i=0; i<POP_SIZE; i++) pop.push(new Snake(gridSize));
    generation = 0; record = 0; bestBrain = null;
    document.getElementById('gen-display').innerText = 0;
    document.getElementById('record-display').innerText = 0;
    document.getElementById('best-fitness-display').innerText = 0;
    document.getElementById('btn-play').disabled = true;
    document.getElementById('btn-watch').disabled = true;
}

function spawnFood(snakes) {
    let valid=false, x, y;
    while(!valid) {
        x = Math.floor(Math.random()*gridSize);
        y = Math.floor(Math.random()*gridSize);
        valid = true;
        for(let s of snakes) if(s && s.body.some(p=>p.x===x && p.y===y)) valid=false;
    }
    return {x,y};
}

// --- ENTRENAMIENTO 1vs1 (BATTLE) ---
function startTraining() {
    stopAll();
    mode = 'TRAINING';
    document.getElementById('status-display').innerText = "ENTRENANDO 1 vs 1...";
    document.getElementById('status-display').style.color = "#0ff";
    if(pop.length===0) initPop();
    
    trainTimer = setInterval(runGenerationBattle, 15); // Muy rápido
}

function runGenerationBattle() {
    let maxFit = 0;
    
    // Mezclar población para emparejamientos aleatorios
    pop.sort(() => Math.random() - 0.5);

    // Batallas por pares
    for(let i=0; i<POP_SIZE; i+=2) {
        let s1 = pop[i];
        let s2 = pop[i+1]; // Si POP_SIZE es impar, el último jugará solo o se ignora. Asumimos par.
        if(!s2) break;

        s1.reset(1,1); s1.direction = RIGHT; // Esquina superior
        s2.reset(gridSize-2, gridSize-2); s2.direction = LEFT; // Esquina inferior

        let battleFood = spawnFood([s1, s2]);
        let steps = 0;
        
        // Loop de batalla simulada
        while(!s1.isDead || !s2.isDead) {
            steps++;
            if(steps > 800) break; // Timeout para evitar loops infinitos

            // 1. Pensar
            if(!s1.isDead) {
                if(s1.direction === -1) s1.direction = Math.floor(Math.random()*4);
                s1.think(battleFood, s2.isDead ? [] : s2.body);
            }
            if(!s2.isDead) {
                if(s2.direction === -1) s2.direction = Math.floor(Math.random()*4);
                s2.think(battleFood, s1.isDead ? [] : s1.body);
            }

            // 2. Mover
            let e1 = false, e2 = false;
            if(!s1.isDead) e1 = s1.update(battleFood, s2.isDead ? [] : s2.body);
            if(!s2.isDead) e2 = s2.update(battleFood, s1.isDead ? [] : s1.body);

            // 3. Comida (Solo 1 la come)
            if(e1 || e2) {
                battleFood = spawnFood([s1, s2]);
            }
            // Si chocan cabeza con cabeza, mueren ambos (ya manejado en update por colisión cuerpo enemigo)
        }

        // Calcular Fitness
        calcFitness(s1);
        calcFitness(s2);

        if(s1.fitness > maxFit) maxFit = s1.fitness;
        if(s2.fitness > maxFit) maxFit = s2.fitness;
        if(s1.score > record) { record = s1.score; document.getElementById('record-display').innerText = record; }
        if(s2.score > record) { record = s2.score; document.getElementById('record-display').innerText = record; }
    }

    evolve();
    document.getElementById('best-fitness-display').innerText = Math.floor(maxFit);
}

function calcFitness(snake) {
    // Fitness prioriza comer sobre vivir sin hacer nada
    snake.fitness = (snake.lifetime * 0.2) + (snake.score * snake.score * 1000);
    if(snake.score > 0) snake.fitness += 500;
}

function evolve() {
    pop.sort((a,b) => b.fitness - a.fitness);
    bestBrain = pop[0].brain.clone();
    
    document.getElementById('gen-display').innerText = generation;
    if(generation>1 || record>0) {
        document.getElementById('btn-play').disabled = false;
        document.getElementById('btn-watch').disabled = false;
    }

    let newPop = [];
    // Elitismo: El mejor pasa directo
    newPop.push(new Snake(gridSize, bestBrain.clone()));
    
    // Cruce y mutación
    for(let i=1; i<POP_SIZE; i++) {
        let parent = pop[Math.floor(Math.random() * (POP_SIZE/5))]; // Elegir del top 20%
        let childBrain = parent.brain.clone();
        childBrain.mutate(0.1);
        newPop.push(new Snake(gridSize, childBrain));
    }
    pop = newPop;
    generation++;

    // Visualización rápida (1 frame)
    let demo = new Snake(gridSize, bestBrain); demo.reset(Math.floor(gridSize/2), Math.floor(gridSize/2));
    draw([demo], {x:2,y:2});
}

// --- JUEGO REAL ---
function startVersus() { if(bestBrain) initGame('VERSUS'); }
function startWatch() { if(bestBrain) initGame('WATCH'); }

function initGame(m) {
    stopAll();
    mode = m;
    isSpectator = false;
    document.getElementById('scoreboard').style.display = 'flex';
    document.getElementById('game-over-modal').style.display = 'none';
    document.getElementById('msg-overlay').style.display = 'none';
    
    // UI Móvil: Minimizar menú para ver juego
    if(window.innerWidth < 768) {
        document.getElementById('ui').classList.add('minimized');
        document.getElementById('show-menu-btn').style.display='block';
    }

    ai = new Snake(gridSize, bestBrain.clone(), false);
    ai.reset(gridSize-2, gridSize-2); ai.direction = LEFT;

    if(mode === 'VERSUS') {
        human = new Snake(gridSize, null, true);
        human.reset(1,1); human.direction = RIGHT;
        document.getElementById('status-display').innerText = "TÚ vs IA";
        document.getElementById('score-h-val').parentElement.style.display = 'inline';
    } else {
        human = null;
        document.getElementById('status-display').innerText = "MODO CINE";
        document.getElementById('score-h-val').parentElement.style.display = 'none';
    }

    food = spawnFood([ai, human].filter(x=>x));
    updateScore();
    gameTimer = setInterval(gameLoop, 110); // Velocidad jugable
}

function gameLoop() {
    let actors = [ai];
    if(human) actors.push(human);

    // 1. Muerte IA
    if(ai.isDead) { showGameOver(true); return; }
    
    // 2. Espectador
    if(human && human.isDead && !isSpectator) {
        isSpectator = true;
        document.getElementById('msg-overlay').style.display = 'block';
    }

    // 3. Updates
    let bodies = human ? human.body : [];
    ai.think(food, bodies);
    let ate1 = ai.update(food, bodies);
    
    let ate2 = false;
    if(human && !human.isDead) {
        ate2 = human.update(food, ai.body);
    }

    if(ate1 || ate2) {
        food = spawnFood(actors);
        updateScore();
    }

    draw(actors, food);
}

function updateScore() {
    document.getElementById('score-ai-val').innerText = ai.score;
    if(human) document.getElementById('score-h-val').innerText = human.score;
}

function showGameOver(aiDied) {
    stopAll();
    let hScore = human ? human.score : 0;
    let aiScore = ai.score;
    let txt = document.getElementById('winner-text');
    
    if(mode === 'WATCH') {
        txt.innerText = "IA TERMINADA"; txt.style.color = "#fff";
        document.getElementById('final-h').parentElement.style.display = 'none';
    } else {
        document.getElementById('final-h').parentElement.style.display = 'block';
        document.getElementById('final-h').innerText = hScore;
        document.getElementById('final-ai').innerText = aiScore;

        if(!human.isDead && aiDied) { txt.innerText = "¡HAS GANADO!"; txt.style.color = "#0f0"; }
        else if(hScore > aiScore) { txt.innerText = "VICTORIA POR PUNTOS"; txt.style.color = "#0f0"; }
        else { txt.innerText = "LA IA GANA"; txt.style.color = "#f05"; }
    }
    document.getElementById('game-over-modal').style.display = 'block';
}

// --------------------------------------------------------------------
// 4. UTILS & INPUTS
// --------------------------------------------------------------------
function stopAll() {
    clearInterval(gameTimer); clearInterval(trainTimer);
    document.getElementById('scoreboard').style.display = 'none';
    document.getElementById('msg-overlay').style.display = 'none';
    mode = 'IDLE';
}

function toggleUI() {
    let ui = document.getElementById('ui');
    let btn = document.getElementById('show-menu-btn');
    ui.classList.toggle('minimized');
    btn.style.display = ui.classList.contains('minimized') ? 'block' : 'none';
}
function closeModal() { document.getElementById('game-over-modal').style.display = 'none'; }

// Inputs Teclado
document.addEventListener('keydown', e => {
    if(!human || human.isDead || mode==='WATCH') return;
    if(e.key==='ArrowUp' && human.direction!==DOWN) human.direction=UP;
    if(e.key==='ArrowDown' && human.direction!==UP) human.direction=DOWN;
    if(e.key==='ArrowLeft' && human.direction!==RIGHT) human.direction=LEFT;
    if(e.key==='ArrowRight' && human.direction!==LEFT) human.direction=RIGHT;
});

// Inputs Móvil (D-Pad)
function handleMobileInput(dir) {
    if(!human || human.isDead || mode==='WATCH') return;
    // Vibración háptica simple si es compatible
    if(navigator.vibrate) navigator.vibrate(10);
    
    if(dir===UP && human.direction!==DOWN) human.direction=UP;
    if(dir===DOWN && human.direction!==UP) human.direction=DOWN;
    if(dir===LEFT && human.direction!==RIGHT) human.direction=LEFT;
    if(dir===RIGHT && human.direction!==LEFT) human.direction=RIGHT;
}

document.getElementById('gridSize').addEventListener('change', (e) => {
    gridSize = parseInt(e.target.value);
    stopAll(); setupScene(gridSize); initPop();
});

// Inicializar
setupScene(gridSize);
initPop();

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    if(window.innerWidth < 768) setupScene(gridSize); // Reajustar cámara para móvil
});

</script>
</body>
</html>