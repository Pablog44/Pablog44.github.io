<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Snake AI 3D - Ultimate Version</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050505; font-family: 'Courier New', Courier, monospace; color: #fff; }
        #ui {
            position: absolute; top: 10px; left: 10px; z-index: 10;
            background: rgba(0, 10, 20, 0.9); padding: 20px; border: 1px solid #0ff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
            border-radius: 8px; width: 320px;
        }
        h1 { margin: 0 0 15px 0; font-size: 22px; color: #0ff; text-shadow: 0 0 10px #0ff; text-align: center; letter-spacing: 2px; }
        .stat { display: flex; justify-content: space-between; margin-bottom: 8px; font-size: 14px; border-bottom: 1px solid #333; padding-bottom: 2px; }
        .highlight { color: #ff0055; font-weight: bold; }
        .highlight-green { color: #00ff55; font-weight: bold; }
        
        select, button {
            width: 100%; padding: 12px; margin-top: 10px;
            background: #000; color: #0ff; border: 1px solid #0ff;
            cursor: pointer; font-weight: bold; text-transform: uppercase;
            transition: all 0.3s;
        }
        button:hover { background: #0ff; color: #000; box-shadow: 0 0 15px #0ff; }
        button:disabled { border-color: #444; color: #444; cursor: not-allowed; background: #111; box-shadow: none; }
        
        #msg-overlay {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 40px; color: white; text-shadow: 0 0 20px red;
            display: none; pointer-events: none; z-index: 20; font-weight: bold;
        }

        #canvas-container { width: 100vw; height: 100vh; }
    </style>
    <!-- Importar Three.js -->
    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
</head>
<body>

<div id="ui">
    <h1>NEURO SNAKE 3D</h1>
    
    <div class="stat"><span>Generación:</span> <span id="gen-display">0</span></div>
    <div class="stat"><span>Mejor Fitness (Actual):</span> <span id="best-fitness-display">0</span></div>
    <div class="stat"><span class="highlight-green">Récord Histórico (Comida):</span> <span id="record-display">0</span></div>
    <div class="stat"><span>Estado:</span> <span id="status-display" style="color: yellow">Esperando...</span></div>
    
    <label for="gridSize" style="font-size: 12px; color: #aaa;">Tamaño del Tablero:</label>
    <select id="gridSize">
        <option value="10">Pequeño (10x10)</option>
        <option value="15" selected>Mediano (15x15)</option>
        <option value="20">Grande (20x20)</option>
    </select>

    <button id="btn-train" onclick="startTraining()">Entrenar IA (Rápido)</button>
    <button id="btn-play" onclick="startVersus()" disabled>Jugar vs IA</button>
    
    <div style="font-size: 11px; margin-top: 15px; color: #888; line-height: 1.4;">
        1. Pulsa <b>ENTRENAR</b> y espera que el Récord suba.<br>
        2. Pulsa <b>JUGAR VS IA</b>.<br>
        3. Si mueres, mirarás a la IA jugar hasta que ella muera.
        <br><br>
        <span style="color: #0055ff">■ TÚ (Azul)</span> vs <span style="color: #ff0055">■ IA (Roja)</span>
    </div>
</div>

<div id="msg-overlay">MODO ESPECTADOR</div>
<div id="canvas-container"></div>

<script>
/**
 * ------------------------------------------------------------------
 * 1. RED NEURONAL (Cerebro)
 * ------------------------------------------------------------------
 */
class NeuralNetwork {
    constructor(inputNodes, hiddenNodes, outputNodes) {
        this.inputNodes = inputNodes;
        this.hiddenNodes = hiddenNodes;
        this.outputNodes = outputNodes;

        // Inicialización de pesos (Xavier/Glorot simplificado)
        this.weightsIH = new Float32Array(this.hiddenNodes * this.inputNodes).map(() => Math.random() * 2 - 1);
        this.weightsHO = new Float32Array(this.outputNodes * this.hiddenNodes).map(() => Math.random() * 2 - 1);
        
        this.biasH = new Float32Array(this.hiddenNodes).map(() => Math.random() * 2 - 1);
        this.biasO = new Float32Array(this.outputNodes).map(() => Math.random() * 2 - 1);
    }

    predict(inputs) {
        // Capa Oculta
        let hidden = new Float32Array(this.hiddenNodes);
        for (let i = 0; i < this.hiddenNodes; i++) {
            let sum = 0;
            for (let j = 0; j < this.inputNodes; j++) {
                sum += inputs[j] * this.weightsIH[i * this.inputNodes + j];
            }
            sum += this.biasH[i];
            // Función de activación ReLU
            hidden[i] = Math.max(0, sum); 
        }

        // Capa Salida
        let output = new Float32Array(this.outputNodes);
        for (let i = 0; i < this.outputNodes; i++) {
            let sum = 0;
            for (let j = 0; j < this.hiddenNodes; j++) {
                sum += hidden[j] * this.weightsHO[i * this.hiddenNodes + j];
            }
            sum += this.biasO[i];
            output[i] = sum; // Linear output (se usa argmax fuera)
        }
        return output;
    }

    clone() {
        let clone = new NeuralNetwork(this.inputNodes, this.hiddenNodes, this.outputNodes);
        clone.weightsIH.set(this.weightsIH);
        clone.weightsHO.set(this.weightsHO);
        clone.biasH.set(this.biasH);
        clone.biasO.set(this.biasO);
        return clone;
    }

    mutate(rate) {
        const mutateVal = (val) => {
            if (Math.random() < rate) {
                // Gaussian mutation (aprox)
                return val + (Math.random() * 0.5 - 0.25); 
            }
            return val;
        };
        this.weightsIH = this.weightsIH.map(mutateVal);
        this.weightsHO = this.weightsHO.map(mutateVal);
        this.biasH = this.biasH.map(mutateVal);
        this.biasO = this.biasO.map(mutateVal);
    }
}

/**
 * ------------------------------------------------------------------
 * 2. LÓGICA DE LA SERPIENTE
 * ------------------------------------------------------------------
 */
const UP = 0, DOWN = 1, LEFT = 2, RIGHT = 3;

class Snake {
    constructor(gridSize, brain = null, isHuman = false) {
        this.gridSize = gridSize;
        this.body = []; 
        this.direction = -1; 
        this.isDead = false;
        this.score = 0;
        this.lifeLeft = 200; 
        this.lifetime = 0;
        this.isHuman = isHuman;
        
        // Input: 24 nodos (visión en 8 direcciones x 3 tipos de objeto)
        // Hidden: 18 nodos
        // Output: 4 nodos (Direcciones)
        this.brain = brain || new NeuralNetwork(24, 18, 4); 
        this.fitness = 0;
    }

    resetPosition(x, y) {
        this.body = [{x: x, y: y}];
        this.direction = -1;
        this.isDead = false;
        this.lifeLeft = 200;
        this.score = 0;
        this.lifetime = 0;
    }

    think(food, obstacles) {
        if (this.isHuman) return;

        const head = this.body[0];
        let inputs = [];

        // Visión en 8 direcciones: N, NE, E, SE, S, SW, W, NW
        const dirs = [
            {x:0, y:-1}, {x:1, y:-1}, {x:1, y:0}, {x:1, y:1},
            {x:0, y:1}, {x:-1, y:1}, {x:-1, y:0}, {x:-1, y:-1}
        ];

        for (let d of dirs) {
            inputs = inputs.concat(this.lookInDirection(d, head, food, obstacles));
        }

        const outputs = this.brain.predict(inputs);
        
        // Argmax para decidir dirección
        let maxVal = -Infinity;
        let choice = 0;
        for(let i=0; i<4; i++){
            if(outputs[i] > maxVal){
                maxVal = outputs[i];
                choice = i;
            }
        }
        
        // Prevenir giro de 180 grados suicida
        const current = this.direction;
        if (choice === UP && current !== DOWN) this.direction = UP;
        else if (choice === DOWN && current !== UP) this.direction = DOWN;
        else if (choice === LEFT && current !== RIGHT) this.direction = LEFT;
        else if (choice === RIGHT && current !== LEFT) this.direction = RIGHT;
        // Si intenta girar 180, mantiene la dirección actual
    }

    lookInDirection(dir, head, food, obstacles) {
        let look = [0, 0, 0]; // [Distancia a Comida, Distancia a Cuerpo/Pared, Distancia a Pared Tablero]
        let x = head.x;
        let y = head.y;
        let distance = 0;
        let foundFood = false;
        let foundBody = false;

        // Raycasting
        x += dir.x; 
        y += dir.y;
        distance += 1;

        while (x >= 0 && x < this.gridSize && y >= 0 && y < this.gridSize) {
            // Check comida
            if (!foundFood && x === food.x && y === food.y) {
                look[0] = 1; // Encontró comida en esta dirección
                foundFood = true;
            }
            // Check cuerpo (propio o enemigo)
            if (!foundBody) {
                 // Comprobar obstáculos externos
                 if (obstacles.some(o => o.x === x && o.y === y)) {
                     look[1] = 1 / distance;
                     foundBody = true;
                 }
                 // Comprobar cuerpo propio
                 if (this.body.some(p => p.x === x && p.y === y)) {
                    look[1] = 1 / distance;
                    foundBody = true;
                 }
            }

            x += dir.x;
            y += dir.y;
            distance += 1;
        }
        
        // Distancia a la pared (inverso de la distancia)
        look[2] = 1 / distance;
        return look;
    }

    update(food, otherSnakesBodies = []) {
        if (this.isDead) return false;
        
        this.lifeLeft--;
        this.lifetime++;
        
        // Muerte por hambre (solo IA)
        if (this.lifeLeft <= 0 && !this.isHuman) {
            this.isDead = true;
            return false;
        }

        let head = { ...this.body[0] };
        
        if (this.direction === UP) head.y -= 1;
        else if (this.direction === DOWN) head.y += 1;
        else if (this.direction === LEFT) head.x -= 1;
        else if (this.direction === RIGHT) head.x += 1;
        else return false; // No se mueve al inicio

        // Colisiones Pared
        if (head.x < 0 || head.x >= this.gridSize || head.y < 0 || head.y >= this.gridSize) {
            this.isDead = true;
            return false;
        }

        // Colisiones consigo mismo
        // Empezamos en 0 para choque inmediato, pero en snake clásico la cola se mueve. 
        // Chequeamos colisión contra el cuerpo SIN la cola actual (porque se va a mover)
        // Simplificación: chocamos contra todo el cuerpo actual.
        for (let part of this.body) {
            if (head.x === part.x && head.y === part.y) {
                this.isDead = true;
                return false;
            }
        }

        // Colisiones con obstáculos externos (la otra serpiente)
        for (let part of otherSnakesBodies) {
            if (head.x === part.x && head.y === part.y) {
                this.isDead = true;
                return false;
            }
        }

        this.body.unshift(head);

        // Comer
        if (head.x === food.x && head.y === food.y) {
            this.score++;
            // Bonus de energía
            this.lifeLeft = Math.min(this.lifeLeft + 150, 600); 
            return true; 
        } else {
            this.body.pop();
            return false;
        }
    }
}

/**
 * ------------------------------------------------------------------
 * 3. ENGINE GRÁFICO (Three.js)
 * ------------------------------------------------------------------
 */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x020205);
scene.fog = new THREE.Fog(0x020205, 10, 60);

const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
document.getElementById('canvas-container').appendChild(renderer.domElement);

// Luces
const ambLight = new THREE.AmbientLight(0x404040, 1.5);
scene.add(ambLight);
const dirLight = new THREE.DirectionalLight(0xffffff, 2);
dirLight.position.set(10, 30, 20);
dirLight.castShadow = true;
scene.add(dirLight);

// Materiales
const matGrid = new THREE.LineBasicMaterial({ color: 0x333333, opacity: 0.3, transparent: true });
const matSnakeAI = new THREE.MeshPhongMaterial({ color: 0xff0055, emissive: 0x550022, shininess: 100 });
const matSnakeHuman = new THREE.MeshPhongMaterial({ color: 0x0088ff, emissive: 0x002288, shininess: 100 });
const matDead = new THREE.MeshLambertMaterial({ color: 0x555555 }); // Color piedra gris
const matFood = new THREE.MeshPhongMaterial({ color: 0x00ff00, emissive: 0x00aa00, emissiveIntensity: 0.8 });

const geoCube = new THREE.BoxGeometry(0.95, 0.95, 0.95);
const geoFood = new THREE.SphereGeometry(0.5, 16, 16);

let gridHelper;
let meshes = [];
let foodMesh;

function setupScene(size) {
    while(scene.children.length > 0){ scene.remove(scene.children[0]); }
    scene.add(ambLight);
    scene.add(dirLight);

    // Grid Floor
    const planeGeo = new THREE.PlaneGeometry(size, size);
    const planeMat = new THREE.MeshLambertMaterial({color:0x111111});
    const plane = new THREE.Mesh(planeGeo, planeMat);
    plane.rotation.x = -Math.PI / 2;
    plane.position.set(size/2 - 0.5, -0.55, size/2 - 0.5);
    plane.receiveShadow = true;
    scene.add(plane);

    gridHelper = new THREE.GridHelper(size, size, 0x00ffff, 0x222222);
    gridHelper.position.set(size/2 - 0.5, -0.5, size/2 - 0.5);
    scene.add(gridHelper);

    camera.position.set(size/2, size * 1.4, size * 1.2); // Cámara aérea
    camera.lookAt(size/2, 0, size/2);

    foodMesh = new THREE.Mesh(geoFood, matFood);
    foodMesh.castShadow = true;
    scene.add(foodMesh);
}

function drawGame(snakes, food) {
    meshes.forEach(m => scene.remove(m));
    meshes = [];

    snakes.forEach(snake => {
        let material;
        if (snake.isDead) material = matDead; // Muerto = Gris
        else material = snake.isHuman ? matSnakeHuman : matSnakeAI;

        snake.body.forEach(part => {
            const mesh = new THREE.Mesh(geoCube, material);
            mesh.position.set(part.x, 0, part.y);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);
            meshes.push(mesh);
        });
    });

    foodMesh.position.set(food.x, 0, food.y);
    
    // Animación suave de la comida
    foodMesh.scale.setScalar(1 + Math.sin(Date.now() * 0.01) * 0.1);

    renderer.render(scene, camera);
}

/**
 * ------------------------------------------------------------------
 * 4. LÓGICA PRINCIPAL (GA & GAME LOOP)
 * ------------------------------------------------------------------
 */
let POPULATION_SIZE = 150;
let population = [];
let bestBrain = null;
let allTimeBestScore = 0; // RECORD HISTÓRICO
let generation = 0;
let gridSize = 15;
let food = {x: 0, y: 0};

let mode = 'IDLE'; 
let humanSnake = null;
let aiSnake = null;
let gameInterval;
let fastTrainInterval;
let spectatorMode = false;

// Input Control
document.addEventListener('keydown', (e) => {
    if (!humanSnake || humanSnake.isDead) return;
    // Prevenir scroll
    if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].indexOf(e.code) > -1) {
        e.preventDefault();
    }
    if (e.key === 'ArrowUp' && humanSnake.direction !== DOWN) humanSnake.direction = UP;
    if (e.key === 'ArrowDown' && humanSnake.direction !== UP) humanSnake.direction = DOWN;
    if (e.key === 'ArrowLeft' && humanSnake.direction !== RIGHT) humanSnake.direction = LEFT;
    if (e.key === 'ArrowRight' && humanSnake.direction !== LEFT) humanSnake.direction = RIGHT;
});

document.getElementById('gridSize').addEventListener('change', (e) => {
    gridSize = parseInt(e.target.value);
    stopGame();
    setupScene(gridSize);
    resetPopulation();
});

function spawnFood() {
    let valid = false;
    let x, y;
    // Intento simple de no spawnear sobre serpientes (en training es random puro por velocidad)
    // En versus lo hacemos bien
    let safeZone = mode === 'VERSUS';
    
    while (!valid) {
        x = Math.floor(Math.random() * gridSize);
        y = Math.floor(Math.random() * gridSize);
        valid = true;
        
        if (safeZone && humanSnake && aiSnake) {
            if (humanSnake.body.some(p => p.x === x && p.y === y)) valid = false;
            if (aiSnake.body.some(p => p.x === x && p.y === y)) valid = false;
        }
    }
    return {x, y};
}

function resetPopulation() {
    population = [];
    for(let i=0; i<POPULATION_SIZE; i++) {
        population.push(new Snake(gridSize));
    }
    generation = 0;
    bestBrain = null;
    // No reseteamos allTimeBestScore a propósito para mantener el récord de la sesión
    document.getElementById('gen-display').innerText = '0';
    document.getElementById('best-fitness-display').innerText = '0';
    document.getElementById('btn-play').disabled = true;
}

// --- ENTRENAMIENTO ---

function startTraining() {
    stopGame();
    mode = 'TRAINING';
    document.getElementById('status-display').innerText = "ENTRENANDO (ACELERADO)...";
    document.getElementById('status-display').style.color = "#0ff";
    
    if (population.length === 0) resetPopulation();
    
    fastTrainInterval = setInterval(() => {
        runGeneration();
    }, 50); // Muy rápido
}

function runGeneration() {
    let genBestScore = 0;

    population.forEach(snake => {
        snake.resetPosition(Math.floor(gridSize/2), Math.floor(gridSize/2));
        let myFood = spawnFood();
        
        while (!snake.isDead) {
            if (snake.direction === -1) snake.direction = Math.floor(Math.random()*4);
            
            // Pensar
            snake.think(myFood, []); // Sin obstáculos en training simple

            // Mover
            let ate = snake.update(myFood, []);
            if (ate) {
                myFood.x = Math.floor(Math.random() * gridSize);
                myFood.y = Math.floor(Math.random() * gridSize);
            }
        }

        // Fitness: Premia mucho comer, poco vivir sin comer
        snake.fitness = (snake.lifetime * 0.5) + (Math.pow(2, snake.score) + (snake.score * 500));
        
        if (snake.score > genBestScore) genBestScore = snake.score;
        
        // Actualizar Récord Histórico
        if (snake.score > allTimeBestScore) {
            allTimeBestScore = snake.score;
            document.getElementById('record-display').innerText = allTimeBestScore;
        }
    });

    evolve();
}

function evolve() {
    // 1. Ordenar por fitness
    population.sort((a, b) => b.fitness - a.fitness);
    
    let bestSnake = population[0];
    
    document.getElementById('gen-display').innerText = generation;
    document.getElementById('best-fitness-display').innerText = Math.floor(bestSnake.fitness);
    
    // Guardar el mejor cerebro actual para jugar luego
    bestBrain = bestSnake.brain.clone();
    
    if (generation > 3 || bestSnake.score > 1) {
        document.getElementById('btn-play').disabled = false;
    }

    // 2. Crear nueva generación
    let newPop = [];
    
    // ELITISMO: Pasar el mejor DIRECTAMENTE sin mutar (El Rey sigue vivo)
    newPop.push(new Snake(gridSize, bestBrain.clone()));

    // Rellenar el resto mutando a los mejores (Top 10%)
    let topCount = Math.floor(POPULATION_SIZE * 0.1);
    for(let i=1; i<POPULATION_SIZE; i++) {
        // Elegir un padre del top
        let parentIndex = Math.floor(Math.random() * topCount);
        let parent = population[parentIndex];
        
        let childBrain = parent.brain.clone();
        childBrain.mutate(0.15); // 15% de tasa de mutación
        
        newPop.push(new Snake(gridSize, childBrain));
    }

    population = newPop;
    generation++;
    
    // Visualizar la mejor red de forma rápida (un frame random) para dar feedback visual
    let demoSnake = new Snake(gridSize, bestBrain);
    demoSnake.resetPosition(Math.floor(gridSize/2), Math.floor(gridSize/2));
    drawGame([demoSnake], {x:2, y:2});
}

// --- JUEGO VERSUS ---

function startVersus() {
    if (!bestBrain) return;
    stopGame();
    mode = 'VERSUS';
    spectatorMode = false;
    document.getElementById('msg-overlay').style.display = 'none';
    document.getElementById('status-display').innerText = "TÚ VS MEJOR IA";
    document.getElementById('status-display').style.color = "#f0f";

    humanSnake = new Snake(gridSize, null, true);
    humanSnake.resetPosition(1, 1);
    humanSnake.direction = RIGHT; 

    aiSnake = new Snake(gridSize, bestBrain.clone(), false);
    aiSnake.resetPosition(gridSize-2, gridSize-2);
    aiSnake.direction = LEFT;

    food = spawnFood();
    drawGame([humanSnake, aiSnake], food);

    // Loop de juego visual (velocidad jugable)
    gameInterval = setInterval(gameLoopVersus, 120);
}

function gameLoopVersus() {
    // Si ambos mueren o la IA muere, fin del juego
    if (aiSnake.isDead) {
        let msg = spectatorMode ? "IA ELIMINADA TRAS TU MUERTE" : (humanSnake.isDead ? "EMPATE" : "¡GANASTE!");
        alert("FIN DE LA PARTIDA: " + msg);
        stopGame();
        return;
    }

    // Si el humano muere, activar MODO ESPECTADOR
    if (humanSnake.isDead && !spectatorMode) {
        spectatorMode = true;
        document.getElementById('msg-overlay').style.display = 'block';
        document.getElementById('status-display').innerText = "ESPECTADOR";
    }

    // --- LÓGICA IA ---
    // La IA ve el cuerpo del humano (vivo o muerto) como obstáculo
    aiSnake.think(food, humanSnake.body);
    let aiAte = aiSnake.update(food, humanSnake.body);

    // --- LÓGICA HUMANO ---
    let hAte = false;
    if (!humanSnake.isDead) {
        // El humano debe evitar a la IA
        hAte = humanSnake.update(food, aiSnake.body);
    }

    // Gestión de comida
    if (aiAte || hAte) {
        food = spawnFood();
    }

    // Renderizar
    drawGame([humanSnake, aiSnake], food);
}

function stopGame() {
    clearInterval(gameInterval);
    clearInterval(fastTrainInterval);
    document.getElementById('msg-overlay').style.display = 'none';
    mode = 'IDLE';
}

// Init
setupScene(gridSize);
resetPopulation();

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

</script>
</body>
</html>