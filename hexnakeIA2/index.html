<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Hex Snake AI - Evolution & Battle</title>
    <style>
        body {
            margin: 0;
            background-color: #1a1a1a;
            color: #eee;
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }

        #container {
            display: flex;
            gap: 20px;
            max-width: 1300px;
        }

        #game-wrapper {
            position: relative;
            border: 2px solid #444;
            border-radius: 10px;
            background: #fff;
            overflow: hidden;
        }

        canvas {
            display: block;
            background-image: radial-gradient(#ddd 1px, transparent 1px);
            background-size: 20px 20px;
        }

        #sidebar {
            width: 320px;
            background: #2d2d2d;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        h2 { margin: 0; color: #4CAF50; font-size: 1.4rem; text-align: center; }
        h3 { margin: 5px 0; font-size: 1rem; color: #aaa; text-align: center; border-bottom: 1px solid #444; padding-bottom: 5px;}

        .panel {
            background: #383838;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #444;
        }

        .stat-row { display: flex; justify-content: space-between; margin-bottom: 5px; font-size: 0.9rem; }
        .val { color: #64b5f6; font-weight: bold; }

        /* Botones de Modo */
        .mode-controls { display: flex; gap: 5px; margin-bottom: 10px; }
        .mode-btn {
            flex: 1;
            padding: 8px;
            font-size: 0.8rem;
            background: #555;
            border: none;
            color: white;
            cursor: pointer;
            border-radius: 4px;
        }
        .mode-btn.active { background: #4CAF50; font-weight: bold; box-shadow: 0 0 5px #4CAF50; }
        .mode-btn:hover:not(.active) { background: #666; }

        /* Controles */
        label { display: block; margin-bottom: 5px; font-size: 0.9rem; color: #aaa; }
        input[type=range] { width: 100%; cursor: pointer; }

        .legend { display: flex; flex-wrap: wrap; gap: 10px; font-size: 0.8rem; margin-top: 5px; justify-content: center;}
        .dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; margin-right: 3px; }

        .controls-guide {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
            text-align: center;
            margin-top: 10px;
        }
        .key {
            background: #eee;
            color: #333;
            border-radius: 4px;
            padding: 2px 0;
            font-weight: bold;
            font-size: 0.8rem;
        }
        .key-space { grid-column: span 3; margin-top: 5px;} 

        #overlay-msg {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none;
            pointer-events: none;
        }

    </style>
</head>
<body>

    <div id="container">
        <div id="game-wrapper">
            <canvas id="gameCanvas" width="700" height="650"></canvas>
            <div id="overlay-msg">
                <h1 id="msg-title">¡Ganaste!</h1>
                <p>Pulsa ESPACIO para reiniciar</p>
            </div>
        </div>

        <div id="sidebar">
            <h2>Hex Neural AI</h2>
            
            <div class="panel">
                <h3>Modo de Juego</h3>
                <div class="mode-controls">
                    <button class="mode-btn active" onclick="setMode('TRAIN')" id="btn-train">Entrenar</button>
                    <button class="mode-btn" onclick="setMode('WATCH')" id="btn-watch">Ver IA</button>
                    <button class="mode-btn" onclick="setMode('PLAY')" id="btn-play">VS IA</button>
                </div>
                <div id="train-stats">
                    <div class="stat-row"><span>Generación:</span> <span id="gen-display" class="val">1</span></div>
                    <div class="stat-row"><span>Vivas:</span> <span id="alive-display" class="val">0</span></div>
                    <div class="stat-row"><span>Récord Gen:</span> <span id="best-score-display" class="val">0</span></div>
                    <div class="stat-row"><span>Récord Global:</span> <span id="high-score-display" class="val">0</span></div>
                </div>
                <div id="play-stats" style="display:none;">
                    <div class="stat-row"><span>Tu Puntuación:</span> <span id="p1-score" class="val" style="color:#2196f3">0</span></div>
                    <div class="stat-row"><span>Puntuación IA:</span> <span id="ai-score" class="val" style="color:#f44336">0</span></div>
                </div>
            </div>

            <div class="panel" id="speed-panel">
                <label>Velocidad de Entrenamiento:</label>
                <input type="range" id="speedSlider" min="1" max="50" value="1">
                <div style="text-align: center; color: #aaa;"><span id="speed-val">1x</span></div>
            </div>

            <div class="panel" id="human-controls" style="display:none;">
                <label style="text-align:center;">Controles (Teclado)</label>
                <div class="controls-guide">
                    <div class="key">Q</div><div class="key">W</div><div class="key">E</div>
                    <div class="key">A</div><div class="key">S</div><div class="key">D</div>
                </div>
                <p style="font-size: 0.7rem; color:#888; text-align:center; margin-top:5px;">
                    Q/E: Arriba Diag | W: Arriba<br>
                    A/D: Abajo Diag | S: Abajo
                </p>
            </div>

            <div class="legend">
                <span><span class="dot" style="background:#2e7d32;"></span>Líder/IA</span>
                <span><span class="dot" style="background:#1565c0;"></span>Tú</span>
                <span><span class="dot" style="background:#d32f2f;"></span>Manzana</span>
                <span><span class="dot" style="background:#888;"></span>Muro</span>
            </div>
        </div>
    </div>

    <script>
        // --- CONFIGURACIÓN ---
        const HEX_SIZE = 18;
        const MAP_RADIUS = 10;
        const POPULATION_SIZE = 250;
        const MUTATION_RATE = 0.05;

        // --- ESTADO DEL SISTEMA ---
        let currentMode = 'TRAIN'; // TRAIN, WATCH, PLAY
        let globalBestBrain = null; // Guardamos el mejor cerebro encontrado
        let gameRunning = true;
        let simSpeed = 1;
        
        // Referencias DOM
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const msgOverlay = document.getElementById('overlay-msg');
        const msgTitle = document.getElementById('msg-title');

        // --- RED NEURONAL ---
        class NeuralNetwork {
            constructor(inputNodes, hiddenNodes, outputNodes, model = null) {
                if (model) {
                    this.inputNodes = model.inputNodes;
                    this.hiddenNodes = model.hiddenNodes;
                    this.outputNodes = model.outputNodes;
                    this.weightsIH = model.weightsIH.map(row => [...row]);
                    this.weightsHO = model.weightsHO.map(row => [...row]);
                    this.biasH = [...model.biasH];
                    this.biasO = [...model.biasO];
                } else {
                    this.inputNodes = inputNodes;
                    this.hiddenNodes = hiddenNodes;
                    this.outputNodes = outputNodes;
                    this.weightsIH = Array(this.hiddenNodes).fill(0).map(() => Array(this.inputNodes).fill(0).map(() => Math.random() * 2 - 1));
                    this.weightsHO = Array(this.outputNodes).fill(0).map(() => Array(this.hiddenNodes).fill(0).map(() => Math.random() * 2 - 1));
                    this.biasH = Array(this.hiddenNodes).fill(0).map(() => Math.random() * 2 - 1);
                    this.biasO = Array(this.outputNodes).fill(0).map(() => Math.random() * 2 - 1);
                }
            }

            predict(inputArray) {
                let hidden = [];
                for (let i = 0; i < this.hiddenNodes; i++) {
                    let sum = 0;
                    for (let j = 0; j < this.inputNodes; j++) sum += inputArray[j] * this.weightsIH[i][j];
                    sum += this.biasH[i];
                    hidden[i] = 1 / (1 + Math.exp(-sum)); // Sigmoid
                }
                let output = [];
                for (let i = 0; i < this.outputNodes; i++) {
                    let sum = 0;
                    for (let j = 0; j < this.hiddenNodes; j++) sum += hidden[j] * this.weightsHO[i][j];
                    sum += this.biasO[i];
                    output[i] = 1 / (1 + Math.exp(-sum));
                }
                return output;
            }

            mutate(rate) {
                function mutateVal(val) {
                    if (Math.random() < rate) return val + (Math.random() * 0.5 - 0.25);
                    return val;
                }
                this.weightsIH = this.weightsIH.map(row => row.map(mutateVal));
                this.weightsHO = this.weightsHO.map(row => row.map(mutateVal));
                this.biasH = this.biasH.map(mutateVal);
                this.biasO = this.biasO.map(mutateVal);
            }
        }

        // --- LÓGICA HEXAGONAL ---
        const DIRECTIONS = [
            { q: 0, r: -1 }, { q: 1, r: -1 }, { q: 1, r: 0 },
            { q: 0, r: 1 }, { q: -1, r: 1 }, { q: -1, r: 0 }
        ];
        // Mapeo de teclas para Humano (QWE ASD)
        const KEY_MAP = {
            'KeyW': 0, 'KeyE': 1, 'KeyD': 2,
            'KeyS': 3, 'KeyA': 4, 'KeyQ': 5
        };

        class Snake {
            constructor(brain = null, isHuman = false, color = null) {
                this.isHuman = isHuman;
                this.color = color;
                // Posiciones iniciales aleatorias seguras
                this.body = [{ q: 0, r: 0 }, { q: 0, r: 1 }, { q: 0, r: 2 }]; 
                if (isHuman) this.body = [{ q: -5, r: 0 }, { q: -5, r: 1 }, { q: -5, r: 2 }];
                else if (currentMode === 'PLAY') this.body = [{ q: 5, r: 0 }, { q: 5, r: 1 }, { q: 5, r: 2 }];

                this.dirIndex = 0; 
                this.nextDirIndex = 0; // Buffer para input humano
                this.alive = true;
                this.score = 0;
                this.lifeTime = 0;
                this.stepsWithoutFood = 0;
                this.fitness = 0;
                this.visitedHistory = []; // Historial corto para evitar bucles

                this.food = this.getNewFoodPos();

                // Inputs: 24
                // 6 Direcciones x (Distancia Muro, Distancia Comida, Hay Cuerpo?, Estuve Aquí Recientemente?)
                if (!isHuman) {
                    if (brain) this.brain = new NeuralNetwork(0,0,0, brain);
                    else this.brain = new NeuralNetwork(24, 18, 6);
                }
            }

            update(enemies = []) {
                if (!this.alive) return;

                this.lifeTime++;
                this.stepsWithoutFood++;

                // Morir por hambre (más estricto para forzar eficiencia)
                // En modo Play/Watch somos más generosos
                let limit = (currentMode === 'TRAIN') ? 100 + (this.score * 50) : 500;
                if (this.stepsWithoutFood > limit) {
                    this.alive = false;
                    return;
                }

                // IA Piensa
                if (!this.isHuman) this.think();
                else this.dirIndex = this.nextDirIndex;

                const head = this.body[0];
                const dir = DIRECTIONS[this.dirIndex];
                const newHead = { q: head.q + dir.q, r: head.r + dir.r };

                // 1. Colisiones
                // Muro
                if (this.hexDist(newHead.q, newHead.r) > MAP_RADIUS) {
                    this.alive = false; return;
                }
                // Propio cuerpo
                if (this.isBodyPart(newHead)) {
                    this.alive = false; return;
                }
                // Enemigos (para modo VS)
                for (let enemy of enemies) {
                    if (!enemy.alive) continue;
                    // Chocar con el cuerpo del enemigo
                    if (enemy.isBodyPart(newHead)) {
                        this.alive = false; return;
                    }
                    // Chocar cabeza con cabeza (empate/mueren ambos)
                    if (enemy.body[0].q === newHead.q && enemy.body[0].r === newHead.r) {
                        this.alive = false; 
                        enemy.alive = false;
                        return;
                    }
                }

                // Guardar historial reciente (últimos 15 pasos)
                this.visitedHistory.push({q: newHead.q, r: newHead.r});
                if (this.visitedHistory.length > 15) this.visitedHistory.shift();

                // Mover
                this.body.unshift(newHead);

                // 2. Comer
                if (newHead.q === this.food.q && newHead.r === this.food.r) {
                    this.score++;
                    this.stepsWithoutFood = 0;
                    this.food = this.getNewFoodPos(enemies);
                    // Crecer (no hacemos pop)
                } else {
                    this.body.pop();
                }
            }

            think() {
                const inputs = [];
                const head = this.body[0];

                for (let i = 0; i < 6; i++) {
                    let dir = DIRECTIONS[i];
                    let distToWall = 0;
                    let distToFood = 0;
                    let bodyInWay = 0;
                    let recentlyVisited = 0;

                    let curr = { ...head };
                    let foundWall = false;

                    // Raycast
                    for (let d = 1; d <= MAP_RADIUS * 2; d++) {
                        curr.q += dir.q;
                        curr.r += dir.r;

                        if (!foundWall) {
                            if (this.hexDist(curr.q, curr.r) > MAP_RADIUS) {
                                distToWall = 1 / d;
                                foundWall = true;
                            } else if (this.isBodyPart(curr)) {
                                bodyInWay = 1;
                            }
                            
                            if (curr.q === this.food.q && curr.r === this.food.r) {
                                distToFood = 1; // Comida encontrada en esta dirección
                            }
                        }
                    }

                    // Input Anti-Bucle: ¿La celda inmediata en esta dirección está en mi historial reciente?
                    let checkPos = { q: head.q + dir.q, r: head.r + dir.r };
                    if (this.wasHereRecently(checkPos)) recentlyVisited = 1;

                    inputs.push(distToWall);
                    inputs.push(distToFood);
                    inputs.push(bodyInWay);
                    inputs.push(recentlyVisited);
                }

                const outputs = this.brain.predict(inputs);
                let maxI = 0;
                for(let i=1; i<outputs.length; i++) if(outputs[i] > outputs[maxI]) maxI = i;
                
                // Evitar giro de 180 grados instantáneo
                let opposite = (this.dirIndex + 3) % 6;
                if (maxI !== opposite) this.dirIndex = maxI;
            }

            wasHereRecently(pos) {
                for(let p of this.visitedHistory) {
                    if (p.q === pos.q && p.r === pos.r) return true;
                }
                return false;
            }

            isBodyPart(pos) {
                for (let part of this.body) {
                    if (part.q === pos.q && part.r === pos.r) return true;
                }
                return false;
            }

            hexDist(q, r) {
                return (Math.abs(q) + Math.abs(q + r) + Math.abs(r)) / 2;
            }

            getNewFoodPos(enemies = []) {
                let pos;
                let safe = false;
                while(!safe) {
                    const q = Math.floor(Math.random() * (MAP_RADIUS * 2 + 1)) - MAP_RADIUS;
                    const r1 = Math.max(-MAP_RADIUS, -q - MAP_RADIUS);
                    const r2 = Math.min(MAP_RADIUS, -q + MAP_RADIUS);
                    const r = Math.floor(Math.random() * (r2 - r1 + 1)) + r1;
                    pos = { q, r };
                    
                    safe = true;
                    if (this.isBodyPart(pos)) safe = false;
                    if (enemies) {
                        for(let e of enemies) if(e.isBodyPart(pos)) safe = false;
                    }
                }
                return pos;
            }

            calculateFitness() {
                // Nueva Fórmula de Eficiencia
                // Base rewards por comida
                let foodReward = this.score * 1000; 
                
                // Penalización por ineficiencia (Pasos Totales)
                // Queremos conseguir manzanas en los mínimos pasos posibles.
                let efficiencyPenalty = this.lifeTime * 1.5; 

                // Bonus pequeño por sobrevivir un poco (para que no se suiciden al inicio)
                // pero topeado para que no hagan looping infinito.
                let survivalBonus = Math.min(this.lifeTime, 200);

                this.fitness = foodReward + survivalBonus - efficiencyPenalty;
                
                // Si mueren por choque contra muro muy rápido, castigo severo
                if (this.score === 0 && this.lifeTime < 20) this.fitness = 0;
                
                if (this.fitness < 0) this.fitness = 0;
            }
        }

        // --- GESTOR DEL JUEGO ---
        let population = [];
        let generation = 1;
        let highScore = 0;
        let humanSnake = null;
        let aiOpponent = null;
        let watchSnake = null;

        function initTraining() {
            population = [];
            for(let i=0; i<POPULATION_SIZE; i++) population.push(new Snake());
        }

        function evolve() {
            population.forEach(s => s.calculateFitness());
            population.sort((a,b) => b.fitness - a.fitness);

            if (population[0].score > highScore) highScore = population[0].score;
            document.getElementById('high-score-display').innerText = highScore;

            // Guardar el mejor cerebro globalmente
            globalBestBrain = population[0].brain;

            const newPop = [];
            // Elitismo (Mejores 10 pasan directo)
            for(let i=0; i<10; i++) newPop.push(new Snake(population[i].brain));

            // Cruce y Mutación
            for(let i=10; i<POPULATION_SIZE; i++) {
                // Selección de torneo simple o aleatorio del top 50%
                const parent = population[Math.floor(Math.random() * (POPULATION_SIZE / 2))];
                const child = new Snake(parent.brain);
                child.brain.mutate(MUTATION_RATE);
                newPop.push(child);
            }
            population = newPop;
            generation++;
            document.getElementById('gen-display').innerText = generation;
        }

        function initVsMode() {
            humanSnake = new Snake(null, true, '#1565c0'); // Azul
            let brainToUse = globalBestBrain; 
            // Si no hay entrenamiento previo, crear uno random
            if (!brainToUse) brainToUse = new NeuralNetwork(24, 18, 6);
            
            aiOpponent = new Snake(brainToUse, false, '#2e7d32'); // Verde
            gameRunning = true;
            msgOverlay.style.display = 'none';
        }

        function initWatchMode() {
            let brainToUse = globalBestBrain;
            if (!brainToUse) {
                 alert("¡Entrena primero para tener una IA que ver!");
                 setMode('TRAIN');
                 return;
            }
            watchSnake = new Snake(brainToUse, false, '#e65100'); // Naranja
            gameRunning = true;
            msgOverlay.style.display = 'none';
        }

        // --- UI & INTERACCIÓN ---
        function setMode(mode) {
            currentMode = mode;
            
            // UI Updates
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            if(mode === 'TRAIN') document.getElementById('btn-train').classList.add('active');
            if(mode === 'WATCH') document.getElementById('btn-watch').classList.add('active');
            if(mode === 'PLAY') document.getElementById('btn-play').classList.add('active');

            const trainStats = document.getElementById('train-stats');
            const playStats = document.getElementById('play-stats');
            const speedPanel = document.getElementById('speed-panel');
            const humanControls = document.getElementById('human-controls');

            if (mode === 'TRAIN') {
                trainStats.style.display = 'block';
                playStats.style.display = 'none';
                speedPanel.style.display = 'block';
                humanControls.style.display = 'none';
                simSpeed = parseInt(document.getElementById('speedSlider').value);
                if (population.length === 0) initTraining();
            } else {
                trainStats.style.display = 'none';
                playStats.style.display = (mode === 'PLAY') ? 'block' : 'none';
                speedPanel.style.display = 'none';
                humanControls.style.display = (mode === 'PLAY') ? 'block' : 'none';
                simSpeed = 1; // Velocidad normal para jugar/ver

                if (mode === 'PLAY') initVsMode();
                if (mode === 'WATCH') initWatchMode();
            }
        }

        document.getElementById('speedSlider').addEventListener('input', (e) => {
            if (currentMode === 'TRAIN') {
                simSpeed = parseInt(e.target.value);
                document.getElementById('speed-val').innerText = simSpeed + "x";
            }
        });

        window.addEventListener('keydown', (e) => {
            if (currentMode === 'PLAY' && humanSnake && humanSnake.alive) {
                if (KEY_MAP[e.code] !== undefined) {
                    // Prevenir 180 grados
                    let reqDir = KEY_MAP[e.code];
                    let opp = (humanSnake.dirIndex + 3) % 6;
                    if (reqDir !== opp) humanSnake.nextDirIndex = reqDir;
                }
            }
            if (e.code === 'Space' && !gameRunning && currentMode !== 'TRAIN') {
                if (currentMode === 'PLAY') initVsMode();
                if (currentMode === 'WATCH') initWatchMode();
            }
        });

        // --- RENDERIZADO ---
        function hexToPixel(q, r) {
            const x = HEX_SIZE * (Math.sqrt(3) * q + Math.sqrt(3)/2 * r);
            const y = HEX_SIZE * (3./2 * r);
            return { x: x + canvas.width / 2, y: y + canvas.height / 2 };
        }

        function drawHexagon(x, y, size, color) {
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const rad = (Math.PI / 180) * (60 * i - 30);
                ctx[i===0?'moveTo':'lineTo'](x + size * Math.cos(rad), y + size * Math.sin(rad));
            }
            ctx.closePath();
            ctx.fillStyle = color;
            ctx.fill();
            ctx.strokeStyle = "rgba(0,0,0,0.2)";
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        function drawGame() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Grid y Muro
            for (let q = -MAP_RADIUS -1; q <= MAP_RADIUS + 1; q++) {
                let r1 = Math.max(-MAP_RADIUS -1, -q - MAP_RADIUS -1);
                let r2 = Math.min(MAP_RADIUS +1, -q + MAP_RADIUS +1);
                for (let r = r1; r <= r2; r++) {
                    const p = hexToPixel(q, r);
                    const dist = (Math.abs(q) + Math.abs(q+r) + Math.abs(r)) / 2;
                    if (dist > MAP_RADIUS) drawHexagon(p.x, p.y, HEX_SIZE, '#444'); // Muro
                    else drawHexagon(p.x, p.y, HEX_SIZE, '#222'); // Suelo
                }
            }

            if (currentMode === 'TRAIN') {
                // Dibujar población
                let best = population[0];
                for (let s of population) {
                    if (!s.alive) continue;
                    if (s.score > best.score || (s.score === best.score && s.lifeTime > best.lifeTime)) best = s;
                }
                document.getElementById('alive-display').innerText = population.filter(s => s.alive).length;
                document.getElementById('best-score-display').innerText = best ? best.score : 0;

                // Dibujar fantasmas
                for (let s of population) {
                    if (!s.alive || s === best) continue;
                    drawSnake(s, 'rgba(255,255,255,0.05)', 'rgba(255,255,255,0.1)');
                }
                // Dibujar mejor
                if (best && best.alive) {
                    drawFood(best.food, '#d32f2f');
                    drawSnake(best, '#4caf50', '#81c784');
                }

            } else if (currentMode === 'PLAY') {
                if (humanSnake.alive) {
                    drawFood(humanSnake.food, '#ffeb3b'); // Comida humano amarilla
                    drawSnake(humanSnake, '#1565c0', '#64b5f6');
                }
                if (aiOpponent.alive) {
                    drawFood(aiOpponent.food, '#d32f2f'); // Comida IA roja
                    drawSnake(aiOpponent, '#2e7d32', '#81c784');
                }
                document.getElementById('p1-score').innerText = humanSnake.score;
                document.getElementById('ai-score').innerText = aiOpponent.score;

            } else if (currentMode === 'WATCH') {
                if (watchSnake.alive) {
                    drawFood(watchSnake.food, '#d32f2f');
                    drawSnake(watchSnake, '#e65100', '#ffb74d');
                }
            }
        }

        function drawFood(pos, color) {
            const p = hexToPixel(pos.q, pos.r);
            drawHexagon(p.x, p.y, HEX_SIZE * 0.8, color);
            // Brillo
            ctx.shadowBlur = 15;
            ctx.shadowColor = color;
            ctx.fillStyle = "white";
            ctx.beginPath(); ctx.arc(p.x, p.y, 4, 0, Math.PI*2); ctx.fill();
            ctx.shadowBlur = 0;
        }

        function drawSnake(snake, bodyCol, headCol) {
            for (let i = snake.body.length -1; i >= 0; i--) {
                const part = snake.body[i];
                const p = hexToPixel(part.q, part.r);
                drawHexagon(p.x, p.y, HEX_SIZE * 0.95, i === 0 ? headCol : bodyCol);
            }
        }

        // --- BUCLE PRINCIPAL ---
        function loop() {
            if (currentMode === 'TRAIN') {
                for(let n=0; n<simSpeed; n++) {
                    let anyAlive = false;
                    for(let s of population) {
                        if(s.alive) {
                            s.update();
                            anyAlive = true;
                        }
                    }
                    if(!anyAlive) evolve();
                }
            } else if (currentMode === 'PLAY' && gameRunning) {
                if (!humanSnake.alive && !aiOpponent.alive) endGame("¡Empate!");
                else if (!humanSnake.alive) endGame("Ganó la IA");
                else if (!aiOpponent.alive) endGame("¡Ganaste!");
                else {
                    // Pasar array de enemigos para colisiones
                    humanSnake.update([aiOpponent]);
                    aiOpponent.update([humanSnake]);
                }
            } else if (currentMode === 'WATCH' && gameRunning) {
                if (!watchSnake.alive) endGame("Fin de la demostración");
                else watchSnake.update();
            }

            drawGame();
            requestAnimationFrame(loop);
        }

        function endGame(text) {
            gameRunning = false;
            msgTitle.innerText = text;
            msgOverlay.style.display = 'block';
        }

        // Inicio
        initTraining();
        requestAnimationFrame(loop);

    </script>
</body>
</html>