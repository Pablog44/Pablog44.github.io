<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Juego tipo Doom con Three.js</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100vh;
      background: #000;
      overflow: hidden;
    }
    /* El canvas se centrará y usará el 85% de la altura */
    #gameCanvas {
      display: block;
      margin: 0 auto;
      background: #000;
    }
  </style>

  <!-- 1. Carga la librería Three.js (UMD) para que defina THREE como global -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  
  <!-- 2. Script principal del juego (usa THREE como global) -->
  <script>
    /***** CONFIGURACIÓN DE THREE.JS Y VARIABLES GLOBALES *****/
    const canvas = document.getElementById('gameCanvas');
    const availableHeight = window.innerHeight * 0.85;
    const canvasSize = Math.min(window.innerWidth, availableHeight);
    canvas.width = canvasSize;
    canvas.height = canvasSize;
    
    // Renderer
    const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
    renderer.setSize(canvasSize, canvasSize);
    
    // Creamos la escena y la cámara
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, canvasSize / canvasSize, 0.1, 1000);
    
    // Variables del jugador (posX, posY en el mapa, angle para la dirección)
    let posX = 7.5, posY = 3.5;
    let angle = 0;
    const moveSpeed = 0.2;
    const rotSpeed = 0.2;
    
    // Posición inicial de la cámara
    camera.position.set(posX, 0.5, posY);
    camera.rotation.y = -angle;
    
    // Exponemos variables para minimap.js
    window.posX = posX;
    window.posY = posY;
    
    /***** CARGA DE TEXTURAS *****/
    const textureLoader = new THREE.TextureLoader();
    const wallTexture    = textureLoader.load('wall.png');
    const floorTexture   = textureLoader.load('floor.png');
    const ceilingTexture = textureLoader.load('ceiling.png');
    const enemyTexture   = textureLoader.load('enemy.png');
    // weapon.png se usa en el HUD (no se muestra en Three.js, sino en 2D overlay)
    
    /***** DEFINICIÓN DEL MAPA (15x15) *****/
    const MAP_WIDTH = 15, MAP_HEIGHT = 15;
    const map = [];
    for (let y = 0; y < MAP_HEIGHT; y++) {
      const row = [];
      for (let x = 0; x < MAP_WIDTH; x++) {
        row.push(1);
      }
      map.push(row);
    }
    // Barra horizontal (filas 1 a 4, columnas 3 a 11)
    for (let y = 1; y <= 4; y++) {
      for (let x = 3; x <= 11; x++) {
        map[y][x] = 0;
      }
    }
    // Barra vertical (filas 4 a 13, columnas 6 a 8)
    for (let y = 4; y <= 13; y++) {
      for (let x = 6; x <= 8; x++) {
        map[y][x] = 0;
      }
    }
    window.map = map; // para minimap.js
    
    /***** CREACIÓN DEL ESCENARIO 3D *****/
    // Suelo
    const floorGeometry = new THREE.PlaneGeometry(MAP_WIDTH, MAP_HEIGHT);
    const floorMaterial = new THREE.MeshBasicMaterial({ map: floorTexture });
    const floorMesh = new THREE.Mesh(floorGeometry, floorMaterial);
    floorMesh.rotation.x = -Math.PI / 2;
    floorMesh.position.set(MAP_WIDTH / 2, 0, MAP_HEIGHT / 2);
    scene.add(floorMesh);
    
    // Techo
    const ceilingGeometry = new THREE.PlaneGeometry(MAP_WIDTH, MAP_HEIGHT);
    const ceilingMaterial = new THREE.MeshBasicMaterial({ map: ceilingTexture });
    const ceilingMesh = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
    ceilingMesh.rotation.x = Math.PI / 2;
    ceilingMesh.position.set(MAP_WIDTH / 2, 1, MAP_HEIGHT / 2);
    scene.add(ceilingMesh);
    
    // Paredes (cada celda del mapa con valor 1 tendrá un cubo)
    const wallGroup = new THREE.Group();
    const wallGeometry = new THREE.BoxGeometry(1, 1, 1);
    const wallMaterial = new THREE.MeshBasicMaterial({ map: wallTexture });
    for (let y = 0; y < MAP_HEIGHT; y++) {
      for (let x = 0; x < MAP_WIDTH; x++) {
        if (map[y][x] === 1) {
          const wall = new THREE.Mesh(wallGeometry, wallMaterial);
          wall.position.set(x + 0.5, 0.5, y + 0.5);
          wallGroup.add(wall);
        }
      }
    }
    scene.add(wallGroup);
    
    /***** ENEMIGOS (SPRITES) *****/
    const enemies = [
      { x: 5.5,  y: 2.5,  alive: true },
      { x: 7.5,  y: 10.5, alive: true },
      { x: 10.5, y: 4.5,  alive: true }
    ];
    window.enemies = enemies; // para minimap.js
    
    enemies.forEach(enemy => {
      const spriteMaterial = new THREE.SpriteMaterial({ map: enemyTexture });
      const sprite = new THREE.Sprite(spriteMaterial);
      sprite.scale.set(0.8, 0.8, 0.8);
      sprite.position.set(enemy.x, 0.5, enemy.y);
      scene.add(sprite);
      enemy.sprite = sprite;
    });
    
    /***** SISTEMA DE DISPAROS *****/
    const bullets = [];
    const bulletSpeed = 0.5;
    let lastShotTime = 0;
    const shootCooldown = 300; // milisegundos
    
    function shootBullet() {
      const currentTime = Date.now();
      if (currentTime - lastShotTime > shootCooldown) {
        const bulletGeometry = new THREE.SphereGeometry(0.1, 8, 8);
        const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
        const bulletMesh = new THREE.Mesh(bulletGeometry, bulletMaterial);
        bulletMesh.position.set(posX, 0.5, posY);
        scene.add(bulletMesh);
        bullets.push({ x: posX, y: posY, angle: angle, mesh: bulletMesh });
        lastShotTime = currentTime;
      }
    }
    window.shootBullet = shootBullet; // exponer para minimap.js si fuera necesario
    
    /***** CONTROLES (TECLADO) *****/
    const keys = {};
    window.keys = keys; // para minimap.js
    window.addEventListener('keydown', e => {
      keys[e.key] = true;
      // Disparo con la barra espaciadora
      if (e.code === "Space") shootBullet();
    });
    window.addEventListener('keyup', e => {
      keys[e.key] = false;
    });
    
    /***** ACTUALIZACIÓN DEL ESTADO *****/
    function update() {
      // Movimiento del jugador (colisión con paredes)
      if (keys["ArrowUp"] || keys["w"]) {
        let newX = posX + Math.cos(angle) * moveSpeed;
        let newY = posY + Math.sin(angle) * moveSpeed;
        if (map[Math.floor(newY)][Math.floor(newX)] === 0) {
          posX = newX;
          posY = newY;
        }
      }
      if (keys["ArrowDown"] || keys["s"]) {
        let newX = posX - Math.cos(angle) * moveSpeed;
        let newY = posY - Math.sin(angle) * moveSpeed;
        if (map[Math.floor(newY)][Math.floor(newX)] === 0) {
          posX = newX;
          posY = newY;
        }
      }
      if (keys["ArrowLeft"] || keys["a"]) angle -= rotSpeed;
      if (keys["ArrowRight"] || keys["d"]) angle += rotSpeed;
      
      // Actualizar cámara
      camera.position.set(posX, 0.5, posY);
      camera.rotation.y = -angle;
      
      // Actualizar balas
      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.x += Math.cos(b.angle) * bulletSpeed;
        b.y += Math.sin(b.angle) * bulletSpeed;
        b.mesh.position.set(b.x, 0.5, b.y);
        
        // Si la bala choca con una pared
        if (!map[Math.floor(b.y)] || map[Math.floor(b.y)][Math.floor(b.x)] > 0) {
          scene.remove(b.mesh);
          bullets.splice(i, 1);
          continue;
        }
        // Colisión con enemigos
        for (let enemy of enemies) {
          if (enemy.alive) {
            let dx = enemy.x - b.x;
            let dy = enemy.y - b.y;
            if (Math.sqrt(dx*dx + dy*dy) < 0.3) {
              enemy.alive = false;
              scene.remove(enemy.sprite);
              scene.remove(b.mesh);
              bullets.splice(i, 1);
              break;
            }
          }
        }
      }
      
      // Movimiento de enemigos (los que estén vivos, persiguen al jugador)
      enemies.forEach(enemy => {
        if (enemy.alive) {
          let dx = posX - enemy.x;
          let dy = posY - enemy.y;
          let dist = Math.sqrt(dx*dx + dy*dy);
          if (dist > 0.5) {
            let newX = enemy.x + (dx / dist) * 0.02;
            let newY = enemy.y + (dy / dist) * 0.02;
            if (map[Math.floor(newY)][Math.floor(newX)] === 0) {
              enemy.x = newX;
              enemy.y = newY;
              enemy.sprite.position.set(newX, 0.5, newY);
            }
          }
        }
      });
      
      // Exponer para minimap
      window.posX = posX;
      window.posY = posY;
      window.playerLife = 100; // valor estático de ejemplo
    }
    
    /***** BUCLE DEL JUEGO *****/
    function gameLoop() {
      update();
      renderer.render(scene, camera);
      requestAnimationFrame(gameLoop);
    }
    gameLoop();
    
    // Adaptar tamaño al redimensionar
    window.addEventListener('resize', () => {
      const newSize = Math.min(window.innerWidth, window.innerHeight * 0.85);
      renderer.setSize(newSize, newSize);
      camera.aspect = newSize / newSize;
      camera.updateProjectionMatrix();
    });
  </script>

  <!-- 3. Script externo para el minimapa y controles móviles -->
  <script src="minimap.js"></script>
</body>
</html>
