<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Juego tipo Doom con Three.js</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100vh;
      background: #000;
      overflow: hidden;
    }
    /* El canvas del juego se centrará y usará el 85% de la altura */
    #gameCanvas {
      display: block;
      margin: 0 auto;
      background: #000;
    }
  </style>
</head>
<body>
  <!-- Canvas para Three.js -->
  <canvas id="gameCanvas"></canvas>
  <!-- El arma (HUD) se mostrará mediante un elemento de imagen -->
  <img id="weaponHUD" src="weapon.png" alt="Weapon HUD" style="position:fixed;bottom:0;left:50%;transform:translateX(-50%);pointer-events:none;max-width:50%;">
  
  <!-- Three.js se carga desde CDN (¡debe cargarse antes de nuestro código!) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/three.min.js"></script>
  
  <!-- Script principal del juego -->
  <script>
    /***** CONFIGURACIÓN Y VARIABLES GLOBALES *****/
    const canvas = document.getElementById('gameCanvas');
    const availableHeight = window.innerHeight * 0.85;
    const canvasSize = Math.min(window.innerWidth, availableHeight);
    canvas.width = canvasSize;
    canvas.height = canvasSize;
    
    // Creamos el renderer usando el canvas existente
    const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
    renderer.setSize(canvasSize, canvasSize);
    renderer.setClearColor(0x000000);
    
    // Creamos la escena y la cámara
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, canvasSize/canvasSize, 0.1, 1000);
    
    // Variables del jugador
    let posX = 7.5, posY = 3.5; // Coordenadas en el mapa (x y z)
    let angle = 0;            // Ángulo en radianes
    const playerHeight = 0.5;
    const moveSpeed = 0.2, rotSpeed = 0.2;
    const keys = {};
    window.keys = keys; // para el minimapa y controles externos
    
    /***** CARGA DE TEXTURAS *****/
    const loader = new THREE.TextureLoader();
    loader.setCrossOrigin("anonymous");
    const wallTexture    = loader.load('wall.png');
    const floorTexture   = loader.load('floor.png');
    const ceilingTexture = loader.load('ceiling.png');
    const enemyTexture   = loader.load('enemy.png');
    // weapon.png se usa en el HUD (elemento <img>)
    
    /***** DEFINICIÓN DEL MAPA (15x15) *****/
    const MAP_WIDTH = 15, MAP_HEIGHT = 15;
    const map = [];
    for (let y = 0; y < MAP_HEIGHT; y++) {
      const row = [];
      for (let x = 0; x < MAP_WIDTH; x++) {
        row.push(1);
      }
      map.push(row);
    }
    // Barra horizontal: filas 1 a 4, columnas 3 a 11 = 0 (camino libre)
    for (let y = 1; y <= 4; y++) {
      for (let x = 3; x <= 11; x++) {
        map[y][x] = 0;
      }
    }
    // Barra vertical: filas 4 a 13, columnas 6 a 8 = 0
    for (let y = 4; y <= 13; y++) {
      for (let x = 6; x <= 8; x++) {
        map[y][x] = 0;
      }
    }
    window.map = map; // para que el minimapa acceda al mapa
    
    /***** CREACIÓN DEL ESCENARIO 3D *****/
    // Suelo: plano texturizado
    const floorGeometry = new THREE.PlaneGeometry(MAP_WIDTH, MAP_HEIGHT);
    const floorMaterial = new THREE.MeshBasicMaterial({ map: floorTexture });
    const floorMesh = new THREE.Mesh(floorGeometry, floorMaterial);
    floorMesh.rotation.x = -Math.PI / 2;
    floorMesh.position.set(MAP_WIDTH / 2, 0, MAP_HEIGHT / 2);
    scene.add(floorMesh);
    
    // Techo: plano texturizado, a altura 1
    const ceilingGeometry = new THREE.PlaneGeometry(MAP_WIDTH, MAP_HEIGHT);
    const ceilingMaterial = new THREE.MeshBasicMaterial({ map: ceilingTexture });
    const ceilingMesh = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
    ceilingMesh.rotation.x = Math.PI / 2;
    ceilingMesh.position.set(MAP_WIDTH / 2, 1, MAP_HEIGHT / 2);
    scene.add(ceilingMesh);
    
    // Paredes: se coloca un cubo en cada celda del mapa con valor 1
    const wallGroup = new THREE.Group();
    const wallGeometry = new THREE.BoxGeometry(1, 1, 1);
    const wallMaterial = new THREE.MeshBasicMaterial({ map: wallTexture });
    for (let y = 0; y < MAP_HEIGHT; y++) {
      for (let x = 0; x < MAP_WIDTH; x++) {
        if (map[y][x] === 1) {
          const wall = new THREE.Mesh(wallGeometry, wallMaterial);
          // Centramos el cubo en la celda (x+0.5, 0.5, y+0.5)
          wall.position.set(x + 0.5, 0.5, y + 0.5);
          wallGroup.add(wall);
        }
      }
    }
    scene.add(wallGroup);
    
    /***** ENEMIGOS (SPRITES) *****/
    const enemiesData = [
      { x: 5.5,  y: 2.5,  alive: true },
      { x: 7.5,  y: 10.5, alive: true },
      { x: 10.5, y: 4.5,  alive: true }
    ];
    enemiesData.forEach(enemy => {
      const spriteMaterial = new THREE.SpriteMaterial({ map: enemyTexture });
      const sprite = new THREE.Sprite(spriteMaterial);
      sprite.scale.set(0.8, 0.8, 0.8);
      sprite.position.set(enemy.x, 0.5, enemy.y);
      scene.add(sprite);
      enemy.sprite = sprite;
    });
    window.enemies = enemiesData;
    
    /***** SISTEMA DE DISPAROS *****/
    const bullets = [];
    const bulletSpeed = 0.5;
    let lastShotTime = 0;
    const shootCooldown = 300; // milisegundos
    function shootBullet() {
      const currentTime = Date.now();
      if (currentTime - lastShotTime > shootCooldown) {
        // Se crea una bala como una esfera pequeña amarilla
        const geometry = new THREE.SphereGeometry(0.1, 8, 8);
        const material = new THREE.MeshBasicMaterial({ color: 0xffff00 });
        const bulletMesh = new THREE.Mesh(geometry, material);
        bulletMesh.position.set(posX, 0.5, posY);
        scene.add(bulletMesh);
        bullets.push({ x: posX, y: posY, angle: angle, mesh: bulletMesh });
        lastShotTime = currentTime;
      }
    }
    window.shootBullet = shootBullet;
    
    /***** EVENTOS DE TECLADO *****/
    window.addEventListener('keydown', e => {
      keys[e.key] = true;
      if (e.code === "Space") shootBullet();
    });
    window.addEventListener('keyup', e => { keys[e.key] = false; });
    
    /***** ACTUALIZACIÓN DEL ESTADO DEL JUEGO *****/
    function update() {
      // Movimiento del jugador
      if (keys["ArrowUp"] || keys["w"]) {
        let newX = posX + Math.cos(angle) * moveSpeed;
        let newY = posY + Math.sin(angle) * moveSpeed;
        if (map[Math.floor(newY)] && map[Math.floor(newY)][Math.floor(newX)] === 0) {
          posX = newX;
          posY = newY;
        }
      }
      if (keys["ArrowDown"] || keys["s"]) {
        let newX = posX - Math.cos(angle) * moveSpeed;
        let newY = posY - Math.sin(angle) * moveSpeed;
        if (map[Math.floor(newY)] && map[Math.floor(newY)][Math.floor(newX)] === 0) {
          posX = newX;
          posY = newY;
        }
      }
      if (keys["ArrowLeft"] || keys["a"]) angle -= rotSpeed;
      if (keys["ArrowRight"] || keys["d"]) angle += rotSpeed;
      
      // Actualizar posición y orientación de la cámara
      camera.position.set(posX, playerHeight, posY);
      const lookTarget = new THREE.Vector3(posX + Math.cos(angle), playerHeight, posY + Math.sin(angle));
      camera.lookAt(lookTarget);
      
      // Actualizar las balas
      for (let i = bullets.length - 1; i >= 0; i--) {
        let b = bullets[i];
        b.x += Math.cos(b.angle) * bulletSpeed;
        b.y += Math.sin(b.angle) * bulletSpeed;
        b.mesh.position.set(b.x, 0.5, b.y);
        // Si la bala impacta en una pared, se elimina
        if (!map[Math.floor(b.y)] || map[Math.floor(b.y)][Math.floor(b.x)] > 0) {
          scene.remove(b.mesh);
          bullets.splice(i, 1);
          continue;
        }
        // Colisión con enemigos
        for (let enemy of enemiesData) {
          if (enemy.alive) {
            let dx = enemy.x - b.x;
            let dy = enemy.y - b.y;
            if (Math.sqrt(dx * dx + dy * dy) < 0.3) {
              enemy.alive = false;
              scene.remove(enemy.sprite);
              scene.remove(b.mesh);
              bullets.splice(i, 1);
              break;
            }
          }
        }
      }
      
      // Movimiento simple de enemigos
      enemiesData.forEach(enemy => {
        if (enemy.alive) {
          let dx = posX - enemy.x;
          let dy = posY - enemy.y;
          let dist = Math.sqrt(dx * dx + dy * dy);
          if (dist > 0.5) {
            let newX = enemy.x + (dx / dist) * 0.02;
            let newY = enemy.y + (dy / dist) * 0.02;
            if (map[Math.floor(newY)][Math.floor(newX)] === 0) {
              enemy.x = newX;
              enemy.y = newY;
              enemy.sprite.position.set(newX, 0.5, newY);
            }
          }
        }
      });
      
      // Exponer variables para el minimapa
      window.posX = posX;
      window.posY = posY;
      window.playerLife = 100; // valor fijo (dummy)
    }
    
    /***** BUCLE DEL JUEGO *****/
    function gameLoop() {
      update();
      renderer.render(scene, camera);
      requestAnimationFrame(gameLoop);
    }
    gameLoop();
    
    // Ajustar renderer y cámara al redimensionar la ventana
    window.addEventListener('resize', () => {
      const newSize = Math.min(window.innerWidth, window.innerHeight * 0.85);
      renderer.setSize(newSize, newSize);
      camera.aspect = newSize / newSize;
      camera.updateProjectionMatrix();
    });
  </script>
  
  <!-- Se carga el script externo para el minimapa y controles móviles -->
  <script src="minimap.js"></script>
</body>
</html>
