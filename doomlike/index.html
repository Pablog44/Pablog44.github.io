<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Juego tipo Doom con Three.js</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100vh;
      background: #000;
      overflow: hidden;
    }
    /* El canvas se centrará y usará el 85% de la altura */
    #gameCanvas {
      display: block;
      margin: 0 auto;
      background: #000;
    }
  </style>

  <!-- 1. Carga la librería Three.js (UMD) para que defina THREE como global -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  
  <!-- 2. Script principal del juego (usa THREE como global) -->
  <script>
    /***** CONFIGURACIÓN DE THREE.JS Y VARIABLES GLOBALES *****/
    const canvas = document.getElementById('gameCanvas');
    const availableHeight = window.innerHeight * 0.85;
    const canvasSize = Math.min(window.innerWidth, availableHeight);
    canvas.width = canvasSize;
    canvas.height = canvasSize;
    
    // Renderer
    const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
    renderer.setSize(canvasSize, canvasSize);
    
    // Escena y cámara
    const scene = new THREE.Scene();
    // Nota: La relación de aspecto se define para un canvas cuadrado
    const camera = new THREE.PerspectiveCamera(75, canvasSize / canvasSize, 0.1, 1000);
    
    // Variables del jugador: posX y posY representan la posición en el mapa (plano 2D),
    // y "angle" es el ángulo de rotación. Con angle = 0, la cámara mira hacia -Z.
    let posX = 7.5, posY = 3.5;
    let angle = 0;
    const moveSpeed = 0.2;
    const rotSpeed  = 0.2;
    
    // Posición inicial de la cámara (y = 0.5 para simular la altura del ojo)
    camera.position.set(posX, 0.5, posY);
    // Con angle = 0, queremos que la cámara mire hacia -Z (por eso usamos rotation.y = angle)
    camera.rotation.y = angle;
    
    // Exponemos variables para el minimapa (minimap.js)
    window.posX = posX;
    window.posY = posY;
    
    /***** CARGA DE TEXTURAS *****/
    const textureLoader = new THREE.TextureLoader();
    const wallTexture    = textureLoader.load('wall.png');
    const floorTexture   = textureLoader.load('floor.png');
    const ceilingTexture = textureLoader.load('ceiling.png');
    const enemyTexture   = textureLoader.load('enemy.png');
    // Nota: weapon.png se usará en el HUD (por ejemplo, como overlay en 2D)
    
    // Configuramos que las texturas de suelo y techo se repitan:
    floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;
    ceilingTexture.wrapS = ceilingTexture.wrapT = THREE.RepeatWrapping;
    
    /***** DEFINICIÓN DEL MAPA (15x15) *****/
    const MAP_WIDTH = 15, MAP_HEIGHT = 15;
    const map = [];
    for (let y = 0; y < MAP_HEIGHT; y++) {
      const row = [];
      for (let x = 0; x < MAP_WIDTH; x++) {
        row.push(1);
      }
      map.push(row);
    }
    // Se define una barra horizontal en filas 1 a 4 y columnas 3 a 11:
    for (let y = 1; y <= 4; y++) {
      for (let x = 3; x <= 11; x++) {
        map[y][x] = 0;
      }
    }
    // Se define una barra vertical en filas 4 a 13 y columnas 6 a 8:
    for (let y = 4; y <= 13; y++) {
      for (let x = 6; x <= 8; x++) {
        map[y][x] = 0;
      }
    }
    window.map = map; // para acceso en minimap.js
    
    /***** CREACIÓN DEL ESCENARIO 3D *****/
    // Configuramos la repetición de la textura para que se muestre una imagen completa por celda:
    floorTexture.repeat.set(MAP_WIDTH, MAP_HEIGHT);
    ceilingTexture.repeat.set(MAP_WIDTH, MAP_HEIGHT);
    
    // Suelo
    const floorGeometry = new THREE.PlaneGeometry(MAP_WIDTH, MAP_HEIGHT);
    const floorMaterial = new THREE.MeshBasicMaterial({ map: floorTexture });
    const floorMesh = new THREE.Mesh(floorGeometry, floorMaterial);
    floorMesh.rotation.x = -Math.PI / 2;
    floorMesh.position.set(MAP_WIDTH / 2, 0, MAP_HEIGHT / 2);
    scene.add(floorMesh);
    
    // Techo
    const ceilingGeometry = new THREE.PlaneGeometry(MAP_WIDTH, MAP_HEIGHT);
    const ceilingMaterial = new THREE.MeshBasicMaterial({ map: ceilingTexture });
    const ceilingMesh = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
    ceilingMesh.rotation.x = Math.PI / 2;
    // Colocamos el techo a altura 1 (simulando 1 metro)
    ceilingMesh.position.set(MAP_WIDTH / 2, 1, MAP_HEIGHT / 2);
    scene.add(ceilingMesh);
    
    // Paredes: por cada celda del mapa con valor 1 se crea un cubo 1×1×1
    const wallGroup = new THREE.Group();
    const wallGeometry = new THREE.BoxGeometry(1, 1, 1);
    const wallMaterial = new THREE.MeshBasicMaterial({ map: wallTexture });
    for (let y = 0; y < MAP_HEIGHT; y++) {
      for (let x = 0; x < MAP_WIDTH; x++) {
        if (map[y][x] === 1) {
          const wall = new THREE.Mesh(wallGeometry, wallMaterial);
          // Se centra el cubo en la celda: (x+0.5, 0.5, y+0.5)
          wall.position.set(x + 0.5, 0.5, y + 0.5);
          wallGroup.add(wall);
        }
      }
    }
    scene.add(wallGroup);
    
    /***** ENEMIGOS (SPRITES) *****/
    const enemies = [
      { x: 5.5,  y: 2.5,  alive: true },
      { x: 7.5,  y: 10.5, alive: true },
      { x: 10.5, y: 4.5,  alive: true }
    ];
    window.enemies = enemies;
    enemies.forEach(enemy => {
      const spriteMaterial = new THREE.SpriteMaterial({ map: enemyTexture });
      const sprite = new THREE.Sprite(spriteMaterial);
      sprite.scale.set(0.8, 0.8, 0.8);
      sprite.position.set(enemy.x, 0.5, enemy.y);
      scene.add(sprite);
      enemy.sprite = sprite;
    });
    
    /***** SISTEMA DE DISPAROS *****/
    const bullets = [];
    const bulletSpeed = 0.5;
    let lastShotTime = 0;
    const shootCooldown = 300; // milisegundos
    
    function shootBullet() {
      const currentTime = Date.now();
      if (currentTime - lastShotTime > shootCooldown) {
        const bulletGeometry = new THREE.SphereGeometry(0.1, 8, 8);
        const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
        const bulletMesh = new THREE.Mesh(bulletGeometry, bulletMaterial);
        bulletMesh.position.set(posX, 0.5, posY);
        scene.add(bulletMesh);
        bullets.push({ x: posX, y: posY, angle: angle, mesh: bulletMesh });
        lastShotTime = currentTime;
      }
    }
    window.shootBullet = shootBullet; // para accesos externos
    
    /***** CONTROLES (TECLADO) *****/
    const keys = {};
    window.keys = keys;
    window.addEventListener('keydown', e => {
      keys[e.key] = true;
      if (e.code === "Space") shootBullet();
    });
    window.addEventListener('keyup', e => {
      keys[e.key] = false;
    });
    
    /***** ACTUALIZACIÓN DEL ESTADO (MOVIMIENTO Y LÓGICA) *****/
    function update() {
      // Definimos el vector "forward" en base al ángulo actual:
      // Con angle = 0 la cámara mira -Z, por lo que:
      // forwardX = sin(angle)
      // forwardY = -cos(angle)
      const forwardX = Math.sin(angle);
      const forwardY = -Math.cos(angle);
      
      if (keys["ArrowUp"] || keys["w"]) {
        const newX = posX + forwardX * moveSpeed;
        const newY = posY + forwardY * moveSpeed;
        if (map[Math.floor(newY)] && map[Math.floor(newY)][Math.floor(newX)] === 0) {
          posX = newX;
          posY = newY;
        }
      }
      if (keys["ArrowDown"] || keys["s"]) {
        const newX = posX - forwardX * moveSpeed;
        const newY = posY - forwardY * moveSpeed;
        if (map[Math.floor(newY)] && map[Math.floor(newY)][Math.floor(newX)] === 0) {
          posX = newX;
          posY = newY;
        }
      }
      if (keys["ArrowLeft"] || keys["a"]) {
        angle -= rotSpeed;
      }
      if (keys["ArrowRight"] || keys["d"]) {
        angle += rotSpeed;
      }
      
      // Actualizamos la posición y orientación de la cámara
      camera.position.set(posX, 0.5, posY);
      camera.rotation.y = angle;
      
      // Actualizar balas
      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        // Utilizamos el mismo vector forward para la bala
        b.x += Math.sin(b.angle) * bulletSpeed;
        b.y -= Math.cos(b.angle) * bulletSpeed;
        b.mesh.position.set(b.x, 0.5, b.y);
        
        // Si la bala choca con una pared
        if (!map[Math.floor(b.y)] || map[Math.floor(b.y)][Math.floor(b.x)] > 0) {
          scene.remove(b.mesh);
          bullets.splice(i, 1);
          continue;
        }
        // Colisión con enemigos
        for (let enemy of enemies) {
          if (enemy.alive) {
            let dx = enemy.x - b.x;
            let dy = enemy.y - b.y;
            if (Math.sqrt(dx * dx + dy * dy) < 0.3) {
              enemy.alive = false;
              scene.remove(enemy.sprite);
              scene.remove(b.mesh);
              bullets.splice(i, 1);
              break;
            }
          }
        }
      }
      
      // Movimiento de enemigos: persiguen al jugador
      enemies.forEach(enemy => {
        if (enemy.alive) {
          let dx = posX - enemy.x;
          let dy = posY - enemy.y;
          let dist = Math.sqrt(dx * dx + dy * dy);
          if (dist > 0.5) {
            const speed = 0.02;
            let newX = enemy.x + (dx / dist) * speed;
            let newY = enemy.y + (dy / dist) * speed;
            if (map[Math.floor(newY)] && map[Math.floor(newY)][Math.floor(newX)] === 0) {
              enemy.x = newX;
              enemy.y = newY;
              enemy.sprite.position.set(newX, 0.5, newY);
            }
          }
        }
      });
      
      // Exponemos la posición actual para el minimapa
      window.posX = posX;
      window.posY = posY;
      window.playerLife = 100; // Valor fijo de ejemplo
    }
    
    /***** BUCLE DEL JUEGO *****/
    function gameLoop() {
      update();
      renderer.render(scene, camera);
      requestAnimationFrame(gameLoop);
    }
    gameLoop();
    
    // Ajuste de tamaño al redimensionar la ventana
    window.addEventListener('resize', () => {
      const newSize = Math.min(window.innerWidth, window.innerHeight * 0.85);
      renderer.setSize(newSize, newSize);
      camera.aspect = newSize / newSize;
      camera.updateProjectionMatrix();
    });
  </script>

  <!-- 3. Script externo para el minimapa y controles móviles -->
  <script src="minimap.js"></script>
</body>
</html>
