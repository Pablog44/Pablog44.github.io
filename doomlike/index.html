<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Juego tipo Doom con Three.js</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100vh;
      background: #000;
      overflow: hidden;
    }
    /* El canvas del juego se centrará y usará el 85% de la altura */
    #gameCanvas {
      display: block;
      margin: 0 auto;
      background: #000;
    }
    /* HUD del arma como imagen superpuesta */
    #weaponHUD {
      position: fixed;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      pointer-events: none;
      max-width: 50%;
    }
  </style>
</head>
<body>
  <!-- Canvas para Three.js -->
  <canvas id="gameCanvas"></canvas>
  <!-- Imagen del arma (HUD) -->
  <img id="weaponHUD" src="weapon.png" alt="Weapon HUD">

  <!-- Three.js desde CDN: debe cargarse antes del script principal -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/three.min.js"></script>
  
  <!-- Script principal del juego -->
  <script>
    /***** CONFIGURACIÓN Y VARIABLES GLOBALES *****/
    const canvas = document.getElementById('gameCanvas');
    const availableHeight = window.innerHeight * 0.85;
    const canvasSize = Math.min(window.innerWidth, availableHeight);
    canvas.width = canvasSize;
    canvas.height = canvasSize;
    
    // Renderer que utiliza nuestro canvas existente
    const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
    renderer.setSize(canvasSize, canvasSize);
    
    // Escena y cámara
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, canvasSize / canvasSize, 0.1, 1000);
    const playerHeight = 0.5;
    
    // Estado del jugador
    let posX = 7.5, posY = 3.5;  // Posición en el mapa (X y Z)
    let angle = 0;             // Ángulo en radianes
    const moveSpeed = 0.2;
    const rotSpeed  = 0.2;
    
    // Objeto de controles (teclado y botones) y se expone globalmente
    const keys = {};
    window.keys = keys;
    
    /***** CARGA DE TEXTURAS *****/
    const loader = new THREE.TextureLoader();
    loader.setCrossOrigin("anonymous");
    const wallTexture    = loader.load('wall.png');
    const floorTexture   = loader.load('floor.png');
    const ceilingTexture = loader.load('ceiling.png');
    const enemyTexture   = loader.load('enemy.png');
    // weapon.png se usa en el HUD (el elemento <img>)
    
    /***** DEFINICIÓN DEL MAPA (15x15) *****/
    const MAP_WIDTH = 15, MAP_HEIGHT = 15;
    const map = [];
    for (let y = 0; y < MAP_HEIGHT; y++) {
      const row = [];
      for (let x = 0; x < MAP_WIDTH; x++) {
        row.push(1);
      }
      map.push(row);
    }
    // Barra horizontal (filas 1 a 4, columnas 3 a 11)
    for (let y = 1; y <= 4; y++) {
      for (let x = 3; x <= 11; x++) {
        map[y][x] = 0;
      }
    }
    // Barra vertical (filas 4 a 13, columnas 6 a 8)
    for (let y = 4; y <= 13; y++) {
      for (let x = 6; x <= 8; x++) {
        map[y][x] = 0;
      }
    }
    window.map = map; // para que minimap.js acceda al mapa
    
    /***** CREACIÓN DEL ESCENARIO 3D *****/
    // Suelo: plano con textura del piso
    const floorGeometry = new THREE.PlaneGeometry(MAP_WIDTH, MAP_HEIGHT);
    const floorMaterial = new THREE.MeshBasicMaterial({ map: floorTexture });
    const floorMesh = new THREE.Mesh(floorGeometry, floorMaterial);
    floorMesh.rotation.x = -Math.PI / 2;
    floorMesh.position.set(MAP_WIDTH / 2, 0, MAP_HEIGHT / 2);
    scene.add(floorMesh);
    
    // Techo: plano con textura del techo, posicionado en altura 1
    const ceilingGeometry = new THREE.PlaneGeometry(MAP_WIDTH, MAP_HEIGHT);
    const ceilingMaterial = new THREE.MeshBasicMaterial({ map: ceilingTexture });
    const ceilingMesh = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
    ceilingMesh.rotation.x = Math.PI / 2;
    ceilingMesh.position.set(MAP_WIDTH / 2, 1, MAP_HEIGHT / 2);
    scene.add(ceilingMesh);
    
    // Paredes: se recorren las celdas del mapa y se coloca un cubo donde haya "1"
    const wallGroup = new THREE.Group();
    const wallGeometry = new THREE.BoxGeometry(1, 1, 1);
    const wallMaterial = new THREE.MeshBasicMaterial({ map: wallTexture });
    for (let y = 0; y < MAP_HEIGHT; y++) {
      for (let x = 0; x < MAP_WIDTH; x++) {
        if (map[y][x] === 1) {
          const wall = new THREE.Mesh(wallGeometry, wallMaterial);
          wall.position.set(x + 0.5, 0.5, y + 0.5);
          wallGroup.add(wall);
        }
      }
    }
    scene.add(wallGroup);
    
    /***** ENEMIGOS (SPRITES) *****/
    const enemiesData = [
      { x: 5.5,  y: 2.5,  alive: true },
      { x: 7.5,  y: 10.5, alive: true },
      { x: 10.5, y: 4.5,  alive: true }
    ];
    enemiesData.forEach(enemy => {
      const spriteMaterial = new THREE.SpriteMaterial({ map: enemyTexture });
      const sprite = new THREE.Sprite(spriteMaterial);
      sprite.scale.set(0.8, 0.8, 0.8);
      sprite.position.set(enemy.x, 0.5, enemy.y);
      scene.add(sprite);
      enemy.sprite = sprite;
    });
    window.enemies = enemiesData; // para el minimapa
    
    /***** SISTEMA DE DISPAROS *****/
    const bullets = [];
    const bulletSpeed = 0.5;
    let lastShotTime = 0;
    const shootCooldown = 300; // milisegundos
    function shootBullet() {
      const currentTime = Date.now();
      if (currentTime - lastShotTime > shootCooldown) {
        const geometry = new THREE.SphereGeometry(0.1, 8, 8);
        const material = new THREE.MeshBasicMaterial({ color: 0xffff00 });
        const bulletMesh = new THREE.Mesh(geometry, material);
        bulletMesh.position.set(posX, 0.5, posY);
        scene.add(bulletMesh);
        bullets.push({ x: posX, y: posY, angle: angle, mesh: bulletMesh });
        lastShotTime = currentTime;
      }
    }
    window.shootBullet = shootBullet; // para controles externos
    
    /***** EVENTOS DE TECLADO *****/
    window.addEventListener('keydown', e => {
      keys[e.key] = true;
      if (e.code === "Space") shootBullet();
    });
    window.addEventListener('keyup', e => { keys[e.key] = false; });
    
    /***** ACTUALIZACIÓN DEL ESTADO DEL JUEGO *****/
    function update() {
      // Movimiento del jugador
      if (keys["ArrowUp"] || keys["w"]) {
        let newX = posX + Math.cos(angle) * moveSpeed;
        let newY = posY + Math.sin(angle) * moveSpeed;
        if (map[Math.floor(newY)] && map[Math.floor(newY)][Math.floor(newX)] === 0) {
          posX = newX;
          posY = newY;
        }
      }
      if (keys["ArrowDown"] || keys["s"]) {
        let newX = posX - Math.cos(angle) * moveSpeed;
        let newY = posY - Math.sin(angle) * moveSpeed;
        if (map[Math.floor(newY)] && map[Math.floor(newY)][Math.floor(newX)] === 0) {
          posX = newX;
          posY = newY;
        }
      }
      if (keys["ArrowLeft"] || keys["a"]) angle -= rotSpeed;
      if (keys["ArrowRight"] || keys["d"]) angle += rotSpeed;
      
      // Actualizar posición de la cámara (se coloca en la posición del jugador)
      camera.position.set(posX, playerHeight, posY);
      camera.rotation.y = -angle;
      
      // Actualizar balas
      for (let i = bullets.length - 1; i >= 0; i--) {
        let b = bullets[i];
        b.x += Math.cos(b.angle) * bulletSpeed;
        b.y += Math.sin(b.angle) * bulletSpeed;
        b.mesh.position.set(b.x, 0.5, b.y);
        // Si la bala choca con una pared, se elimina
        if (!map[Math.floor(b.y)] || map[Math.floor(b.y)][Math.floor(b.x)] > 0) {
          scene.remove(b.mesh);
          bullets.splice(i, 1);
          continue;
        }
        // Colisión con enemigos
        for (let enemy of enemiesData) {
          if (enemy.alive) {
            let dx = enemy.x - b.x;
            let dy = enemy.y - b.y;
            if (Math.sqrt(dx * dx + dy * dy) < 0.3) {
              enemy.alive = false;
              scene.remove(enemy.sprite);
              scene.remove(b.mesh);
              bullets.splice(i, 1);
              break;
            }
          }
        }
      }
      
      // Movimiento simple de enemigos
      enemiesData.forEach(enemy => {
        if (enemy.alive) {
          let dx = posX - enemy.x;
          let dy = posY - enemy.y;
          let dist = Math.sqrt(dx * dx + dy * dy);
          if (dist > 0.5) {
            let newX = enemy.x + (dx / dist) * 0.02;
            let newY = enemy.y + (dy / dist) * 0.02;
            if (map[Math.floor(newY)][Math.floor(newX)] === 0) {
              enemy.x = newX;
              enemy.y = newY;
              enemy.sprite.position.set(newX, 0.5, newY);
            }
          }
        }
      });
      
      // Se exponen globalmente para el minimapa
      window.posX = posX;
      window.posY = posY;
      window.playerLife = 100; // Valor fijo (dummy)
    }
    
    /***** BUCLE DEL JUEGO *****/
    function gameLoop() {
      update();
      renderer.render(scene, camera);
      requestAnimationFrame(gameLoop);
    }
    gameLoop();
    
    // Adaptación al redimensionar la ventana
    window.addEventListener('resize', () => {
      const newSize = Math.min(window.innerWidth, window.innerHeight * 0.85);
      renderer.setSize(newSize, newSize);
      camera.aspect = newSize / newSize;
      camera.updateProjectionMatrix();
    });
  </script>
  
  <!-- Se carga el script externo para el minimapa y controles móviles -->
  <script src="minimap.js"></script>
</body>
</html>
