<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Snake Hexagonal - Touch & Gamepad</title>
    <style>
        body {
            margin: 0;
            background-color: #f0f0f0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            touch-action: none; /* Previene scroll en móvil */
        }

        #game-container {
            position: relative;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            border-radius: 10px;
            background: #fff;
            overflow: hidden;
        }

        canvas {
            display: block;
            background-color: #ffffff;
            background-image: radial-gradient(#e0e0e0 1px, transparent 1px);
            background-size: 20px 20px;
            /* Ajuste para móvil */
            max-width: 100vw;
            max-height: 80vh;
        }

        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 8px;
            pointer-events: none;
            font-size: 14px;
        }

        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 20px;
            text-align: center;
            border-radius: 15px;
            display: none;
            z-index: 100;
        }
        
        button.restart-btn {
            background: #4CAF50;
            border: none;
            color: white;
            padding: 10px 20px;
            font-size: 16px;
            margin-top: 10px;
            cursor: pointer;
            border-radius: 5px;
        }

        /* --- CONTROLADOR HEXAGONAL TÁCTIL --- */
        #hex-controller {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 160px;
            height: 160px;
            z-index: 50;
            /* Ocultar en escritorio si se prefiere, pero útil para pantallas táctiles híbridas */
            opacity: 0.8;
        }

        /* Los 6 botones triangulares */
        .hex-btn {
            position: absolute;
            width: 50%;
            height: 50%;
            background: rgba(33, 150, 243, 0.5);
            border: 1px solid rgba(255,255,255,0.3);
            top: 50%;
            left: 50%;
            transform-origin: 0 0; /* Rotar desde el centro del contenedor */
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            /* Forma triangular */
            clip-path: polygon(0 0, 100% 0, 100% 100%); 
            -webkit-tap-highlight-color: transparent;
        }

        .hex-btn:active, .hex-btn.active {
            background: rgba(33, 150, 243, 0.9);
        }

        /* Posicionamiento y rotación de cada "gajo" para formar el hexágono */
        /* Nota: Se usa skew para deformar el cuadrado en un triángulo equilátero de 60 grados aprox */
        /* Simplificación: Usaremos rotación simple con iconos posicionados */
        
        .hex-slice {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            border-radius: 50%;
        }
        
        /* Reimplementación del Hex-Pad usando posicionamiento radial */
        .dpad-btn {
            position: absolute;
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 50%;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            user-select: none;
            backdrop-filter: blur(2px);
            border: 2px solid rgba(255,255,255,0.5);
            transition: background 0.1s;
        }
        .dpad-btn:active { background: rgba(0,0,0,0.6); }
        .dpad-center { top: 55px; left: 55px; width: 50px; height: 50px; background: none; border:none; font-size: 10px; text-align:center; color: #333;}

        /* Posiciones reloj: 12 es arriba, pero necesitamos hexágono */
        /* W (NE) */
        .d-ne { top: 5px; right: 10px; }
        /* D (E) */
        .d-e { top: 55px; right: -20px; }
        /* X (SE) */
        .d-se { bottom: 5px; right: 10px; }
        /* Z (SW) */
        .d-sw { bottom: 5px; left: 10px; }
        /* A (W) */
        .d-w { top: 55px; left: -20px; }
        /* Q (NW) */
        .d-nw { top: 5px; left: 10px; }

        @media (min-width: 1024px) {
            /* En PC grande, quizás hacer el control táctil más transparente o pequeño */
            #hex-controller { opacity: 0.3; }
            #hex-controller:hover { opacity: 1; }
        }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        
        <div id="ui">
            <strong>Hex Snake</strong><br>
            Score: <span id="score">0</span><br>
            <span style="font-size: 0.8em; color: #666;">Teclado: Q,W,E,A,S,D o Flechas<br>Mando compatible</span>
        </div>

        <div id="game-over">
            <h2>¡Juego Terminado!</h2>
            <p>Score: <span id="final-score">0</span></p>
            <button class="restart-btn" onclick="resetGame()">Jugar de nuevo</button>
        </div>

        <!-- Control Táctil Hexagonal -->
        <div id="hex-controller">
            <div class="dpad-center">HEX<br>PAD</div>
            <div class="dpad-btn d-nw" data-key="q">↖</div>
            <div class="dpad-btn d-ne" data-key="w">↗</div>
            <div class="dpad-btn d-e" data-key="d">→</div>
            <div class="dpad-btn d-se" data-key="x">↘</div>
            <div class="dpad-btn d-sw" data-key="z">↙</div>
            <div class="dpad-btn d-w" data-key="a">←</div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        
        // Ajustar tamaño del canvas a la ventana (Responsive)
        function resizeCanvas() {
            // Mantenemos la relación de aspecto o ajustamos
            // Para este juego es mejor un tamaño fijo lógico y escalar con CSS,
            // pero aquí ajustaremos las dimensiones lógicas para que se vea nítido.
            // Si estás en móvil, reducimos un poco el "zoom"
            if(window.innerWidth < 800) {
                canvas.style.width = '100%';
                canvas.style.height = 'auto';
            }
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // --- CONFIGURACIÓN ---
        const HEX_SIZE = 22; 
        const MAP_RADIUS = 8; 
        const SPEED = 140; 

        const COLORS = {
            center: '#ffe0b2', 
            ring1: '#ef9a9a',  
            ring2: '#90caf9',  
            outer: '#a5d6a7',  
            border: '#555',    
            snakeHead: '#212121',
            snakeBody: '#424242',
            food: '#d32f2f'    
        };

        const DIRECTIONS = {
            NW: { q: 0, r: -1 }, // Q
            NE: { q: 1, r: -1 }, // W
            E:  { q: 1, r: 0 },  // D
            SE: { q: 0, r: 1 },  // X
            SW: { q: -1, r: 1 }, // Z
            W:  { q: -1, r: 0 }  // A
        };

        let snake = [];
        let direction = DIRECTIONS.E;
        let nextDirection = DIRECTIONS.E;
        let food = null;
        let gameRunning = false;
        let lastTime = 0;
        let score = 0;
        let hexGrid = []; 

        // --- LOGICA HEX ---
        function hexToPixel(q, r) {
            const x = HEX_SIZE * (Math.sqrt(3) * q + Math.sqrt(3)/2 * r);
            const y = HEX_SIZE * (3./2 * r);
            return { x: x + canvas.width / 2, y: y + canvas.height / 2 };
        }

        function hexDistance(q, r) {
            return (Math.abs(q) + Math.abs(q + r) + Math.abs(r)) / 2;
        }

        function generateGrid() {
            hexGrid = [];
            for (let q = -MAP_RADIUS; q <= MAP_RADIUS; q++) {
                let r1 = Math.max(-MAP_RADIUS, -q - MAP_RADIUS);
                let r2 = Math.min(MAP_RADIUS, -q + MAP_RADIUS);
                for (let r = r1; r <= r2; r++) {
                    hexGrid.push({ q, r });
                }
            }
        }

        function isOpposite(d1, d2) {
            return (d1.q + d2.q === 0) && (d1.r + d2.r === 0);
        }

        function changeDirection(newDir) {
            if (!isOpposite(direction, newDir)) {
                nextDirection = newDir;
            }
        }

        // --- GAMEPAD LOGIC ---
        function updateGamepad() {
            const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
            const gp = gamepads[0]; // Usamos el primer mando conectado

            if (!gp) return;

            // Ejes del Stick Izquierdo (normalmente axes 0 y 1)
            const x = gp.axes[0];
            const y = gp.axes[1];

            // Deadzone (zona muerta) para evitar movimientos fantasma
            if (Math.abs(x) < 0.2 && Math.abs(y) < 0.2) return;

            // Calcular ángulo en grados (0 a 360)
            let angle = Math.atan2(y, x) * (180 / Math.PI);
            
            // Math.atan2 devuelve de -180 a 180. Convertimos a 0-360 para facilitar.
            // 0 es Derecha (Este). 90 es Abajo. -90 es Arriba.
            
            // Mapeo de ángulos a direcciones hexagonales
            // Derecha (E): -30 a 30
            // Abajo-Derecha (SE): 30 a 90
            // Abajo-Izquierda (SW): 90 a 150
            // Izquierda (W): 150 a 180 Y -180 a -150
            // Arriba-Izquierda (NW): -150 a -90
            // Arriba-Derecha (NE): -90 a -30

            let newDir = null;

            if (angle > -30 && angle <= 30) newDir = DIRECTIONS.E;
            else if (angle > 30 && angle <= 90) newDir = DIRECTIONS.SE;
            else if (angle > 90 && angle <= 150) newDir = DIRECTIONS.SW;
            else if (angle > 150 || angle <= -150) newDir = DIRECTIONS.W;
            else if (angle > -150 && angle <= -90) newDir = DIRECTIONS.NW;
            else if (angle > -90 && angle <= -30) newDir = DIRECTIONS.NE;

            if (newDir) changeDirection(newDir);
        }

        // --- LOOP PRINCIPAL ---
        function initGame() {
            generateGrid();
            snake = [{ q: 0, r: 0 }, { q: -1, r: 0 }, { q: -2, r: 0 }];
            direction = DIRECTIONS.E;
            nextDirection = DIRECTIONS.E;
            score = 0;
            scoreEl.innerText = score;
            gameRunning = true;
            document.getElementById('game-over').style.display = 'none';
            spawnFood();
            requestAnimationFrame(gameLoop);
        }

        function gameLoop(timestamp) {
            if (!gameRunning) return;

            // Polling del mando en cada frame
            updateGamepad();

            // Control de velocidad de la serpiente
            if (timestamp - lastTime > SPEED) {
                update();
                draw();
                lastTime = timestamp;
            }
            requestAnimationFrame(gameLoop);
        }

        function spawnFood() {
            let valid = false;
            while (!valid) {
                const randomIndex = Math.floor(Math.random() * hexGrid.length);
                let pos = hexGrid[randomIndex];
                let collision = false;
                for (let segment of snake) {
                    if (segment.q === pos.q && segment.r === pos.r) collision = true;
                }
                if (!collision) {
                    food = pos;
                    valid = true;
                }
            }
        }

        function update() {
            direction = nextDirection;
            const head = snake[0];
            const newHead = { q: head.q + direction.q, r: head.r + direction.r };

            // Colisiones
            if (hexDistance(newHead.q, newHead.r) > MAP_RADIUS) return endGame();
            for (let segment of snake) {
                if (segment.q === newHead.q && segment.r === newHead.r) return endGame();
            }

            snake.unshift(newHead);

            if (food && newHead.q === food.q && newHead.r === food.r) {
                score += 10;
                scoreEl.innerText = score;
                spawnFood();
            } else {
                snake.pop();
            }
        }

        function endGame() {
            gameRunning = false;
            document.getElementById('final-score').innerText = score;
            document.getElementById('game-over').style.display = 'block';
        }

        function resetGame() {
            initGame();
        }

        // --- DIBUJO ---
        function drawHexagon(ctx, x, y, size, color, stroke = true) {
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle_rad = (Math.PI / 180) * (60 * i - 30);
                const px = x + size * Math.cos(angle_rad);
                const py = y + size * Math.sin(angle_rad);
                if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.fillStyle = color;
            ctx.fill();
            if (stroke) {
                ctx.strokeStyle = COLORS.border;
                ctx.lineWidth = 1;
                ctx.stroke();
            }
            // Puntos en vértices
            ctx.fillStyle = '#333';
            for (let i = 0; i < 6; i++) {
                const angle_rad = (Math.PI / 180) * (60 * i - 30);
                const px = x + size * Math.cos(angle_rad);
                const py = y + size * Math.sin(angle_rad);
                ctx.beginPath(); ctx.arc(px, py, 1.5, 0, Math.PI * 2); ctx.fill();
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Grid
            for (let hex of hexGrid) {
                const pos = hexToPixel(hex.q, hex.r);
                const dist = hexDistance(hex.q, hex.r);
                let color = COLORS.outer;
                if (dist === 0) color = COLORS.center;
                else if (dist <= 3) color = COLORS.ring1;
                else if (dist <= 6) color = COLORS.ring2;
                drawHexagon(ctx, pos.x, pos.y, HEX_SIZE, color);
            }

            // Food
            if (food) {
                const fPos = hexToPixel(food.q, food.r);
                drawHexagon(ctx, fPos.x, fPos.y, HEX_SIZE * 0.8, COLORS.food, false);
            }

            // Snake
            for (let i = 0; i < snake.length; i++) {
                const s = snake[i];
                const sPos = hexToPixel(s.q, s.r);
                drawHexagon(ctx, sPos.x, sPos.y, HEX_SIZE * 0.9, i===0?COLORS.snakeHead:COLORS.snakeBody, false);
            }
        }

        // --- EVENTOS INPUT ---
        
        // 1. Teclado
        window.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            let newDir = null;
            switch(key) {
                case 'q': case '7': newDir = DIRECTIONS.NW; break;
                case 'w': case '9': newDir = DIRECTIONS.NE; break;
                case 'd': case '6': case 'arrowright': newDir = DIRECTIONS.E; break;
                case 'x': case '3': newDir = DIRECTIONS.SE; break;
                case 'z': case '1': newDir = DIRECTIONS.SW; break;
                case 'a': case '4': case 'arrowleft': newDir = DIRECTIONS.W; break;
            }
            if (newDir) changeDirection(newDir);
        });

        // 2. Botones Táctiles
        const touchBtns = document.querySelectorAll('.dpad-btn');
        touchBtns.forEach(btn => {
            // Soporte para mouse click
            btn.addEventListener('mousedown', (e) => {
                e.preventDefault(); // Evitar selección texto
                handleTouchInput(btn.dataset.key);
            });
            // Soporte para touch
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault(); // Evitar scroll
                handleTouchInput(btn.dataset.key);
            });
        });

        function handleTouchInput(key) {
            let newDir = null;
            if(key === 'q') newDir = DIRECTIONS.NW;
            if(key === 'w') newDir = DIRECTIONS.NE;
            if(key === 'd') newDir = DIRECTIONS.E;
            if(key === 'x') newDir = DIRECTIONS.SE;
            if(key === 'z') newDir = DIRECTIONS.SW;
            if(key === 'a') newDir = DIRECTIONS.W;
            
            if (newDir) changeDirection(newDir);
        }

        // Iniciar
        initGame();

    </script>
</body>
</html>