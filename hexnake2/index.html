<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Snake Hexagonal Responsive</title>
    <style>
        :root {
            --bg-color: #f0f0f0;
            --control-bg: #e0e0e0;
            --control-size: 220px; /* Tamaño del panel de control */
        }

        body {
            margin: 0;
            background-color: var(--bg-color);
            height: 100vh; /* Altura completa viewport */
            width: 100vw;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden; /* Sin scroll */
            touch-action: none;
            display: flex;
        }

        /* CONTENEDOR PRINCIPAL */
        #main-wrapper {
            display: flex;
            width: 100%;
            height: 100%;
        }

        /* --- ÁREA DE JUEGO (CANVAS) --- */
        #game-area {
            position: relative;
            flex-grow: 1; /* Ocupa todo el espacio disponible */
            background: #ffffff;
            background-image: radial-gradient(#e0e0e0 1px, transparent 1px);
            background-size: 20px 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        canvas {
            display: block;
            /* El canvas se redimensionará por JS */
        }

        /* UI SUPERPUESTA EN CANVAS */
        #ui-layer {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.85);
            padding: 8px 12px;
            border-radius: 8px;
            pointer-events: none;
            font-size: 14px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 25px;
            text-align: center;
            border-radius: 15px;
            display: none;
            z-index: 100;
            min-width: 200px;
        }

        button.restart-btn {
            background: #4CAF50;
            border: none;
            color: white;
            padding: 12px 24px;
            font-size: 18px;
            margin-top: 15px;
            cursor: pointer;
            border-radius: 5px;
            touch-action: manipulation;
        }

        /* --- ÁREA DE CONTROLES --- */
        #controls-area {
            background-color: var(--control-bg);
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            z-index: 50;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.1);
        }

        /* DISEÑO RESPONSIVE (MEDIA QUERIES) */

        /* MODO VERTICAL (Móvil normal) */
        @media (orientation: portrait) {
            #main-wrapper {
                flex-direction: column; /* Apilar verticalmente */
            }
            #game-area {
                width: 100%;
                /* El alto se ajusta automáticamente con flex */
            }
            #controls-area {
                width: 100%;
                /* CAMBIO AQUI: Aumenté la altura y añadí padding-bottom */
                height: 320px; /* Antes 260px, más alto para dar espacio */
                border-top: 1px solid #ccc;
                padding-bottom: 80px; /* Esto empuja los botones hacia arriba evitando la barra del navegador */
                box-sizing: border-box; 
            }
        }

        /* MODO HORIZONTAL (Móvil girado o PC) */
        @media (orientation: landscape) {
            #main-wrapper {
                flex-direction: row; /* Lado a lado */
            }
            #game-area {
                height: 100%;
                /* El ancho se ajusta con flex */
            }
            #controls-area {
                width: 260px; /* Ancho fijo a la derecha */
                height: 100%;
                border-left: 1px solid #ccc;
            }
        }

        /* --- EL MANDO HEXAGONAL --- */
        #hex-controller {
            position: relative;
            width: 200px;
            height: 200px;
        }

        .dpad-btn {
            position: absolute;
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            color: #333;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 24px;
            user-select: none;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            border: 2px solid #bbb;
            transition: transform 0.1s, background 0.1s;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }

        .dpad-btn:active {
            background: #bbb;
            transform: scale(0.95);
        }

        .dpad-center {
            top: 70px; left: 70px;
            width: 60px; height: 60px;
            background: #333; color: #fff;
            border: none; font-size: 12px;
            text-align: center; display: flex;
            flex-direction: column; justify-content: center;
        }

        /* Posicionamiento Radial Exacto para el mando de 200px */
        /* Centro es 100,100. Radio aprox 70px */
        .d-ne { top: 10px; right: 20px; }  /* W */
        .d-e  { top: 70px; right: -10px; } /* D */
        .d-se { bottom: 10px; right: 20px;}/* X */
        .d-sw { bottom: 10px; left: 20px; }/* Z */
        .d-w  { top: 70px; left: -10px; }  /* A */
        .d-nw { top: 10px; left: 20px; }   /* Q */

    </style>
</head>
<body>

    <div id="main-wrapper">
        <div id="game-area">
            <canvas id="gameCanvas"></canvas>
            
            <div id="ui-layer">
                <strong>Hex Snake</strong><br>
                Puntos: <span id="score">0</span>
            </div>

            <div id="game-over">
                <h2>¡Game Over!</h2>
                <p>Puntuación: <span id="final-score">0</span></p>
                <button class="restart-btn" onclick="resetGame()">Reiniciar</button>
            </div>
        </div>

        <div id="controls-area">
            <div id="hex-controller">
                <div class="dpad-center">HEX<br>PAD</div>
                <div class="dpad-btn d-nw" data-key="q">↖</div>
                <div class="dpad-btn d-ne" data-key="w">↗</div>
                <div class="dpad-btn d-e"  data-key="d">→</div>
                <div class="dpad-btn d-se" data-key="x">↘</div>
                <div class="dpad-btn d-sw" data-key="z">↙</div>
                <div class="dpad-btn d-w"  data-key="a">←</div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const gameArea = document.getElementById('game-area');
        
        // Configuración Dinámica
        let HEX_SIZE = 22; // Se recalculará
        const MAP_RADIUS = 8; 
        const SPEED = 140; 

        const COLORS = {
            center: '#ffe0b2', ring1: '#ef9a9a', ring2: '#90caf9', outer: '#a5d6a7',  
            border: '#555', snakeHead: '#212121', snakeBody: '#424242', food: '#d32f2f'    
        };

        const DIRECTIONS = {
            NW: { q: 0, r: -1 }, NE: { q: 1, r: -1 }, E:  { q: 1, r: 0 },
            SE: { q: 0, r: 1 }, SW: { q: -1, r: 1 }, W:  { q: -1, r: 0 }
        };

        let snake = [];
        let direction = DIRECTIONS.E;
        let nextDirection = DIRECTIONS.E;
        let food = null;
        let gameRunning = false;
        let lastTime = 0;
        let score = 0;
        let hexGrid = []; 

        // --- RESPONSIVE SYSTEM ---
        function resizeGame() {
            // Obtener dimensiones del contenedor padre (game-area)
            const width = gameArea.clientWidth;
            const height = gameArea.clientHeight;

            // Ajustar canvas al tamaño exacto del contenedor
            canvas.width = width;
            canvas.height = height;

            // Calcular el tamaño óptimo del hexágono para que el mapa quepa en pantalla
            // El mapa tiene un diámetro de (MAP_RADIUS * 2 + 1) hexágonos.
            // Aproximación matemática para ajustar el zoom:
            const mapWidthHex = (MAP_RADIUS * 2 + 1) * 1.8; // Factor horizontal
            const mapHeightHex = (MAP_RADIUS * 2 + 1) * 1.6; // Factor vertical
            
            const sizeW = width / mapWidthHex;
            const sizeH = height / mapHeightHex;

            // Elegimos el menor para asegurar que quepa
            HEX_SIZE = Math.min(sizeW, sizeH);
            // Limitar tamaño máximo para PC
            if(HEX_SIZE > 35) HEX_SIZE = 35; 
            
            // Si el juego está pausado, redibujamos para que no se vea borroso
            if(!gameRunning && snake.length > 0) draw(); 
        }

        window.addEventListener('resize', resizeGame);
        // Llamada inicial
        setTimeout(resizeGame, 100); // Pequeño delay para asegurar carga del layout

        // --- LOGICA HEX ---
        function hexToPixel(q, r) {
            const x = HEX_SIZE * (Math.sqrt(3) * q + Math.sqrt(3)/2 * r);
            const y = HEX_SIZE * (3./2 * r);
            // Centramos usando las dimensiones actuales del canvas
            return { x: x + canvas.width / 2, y: y + canvas.height / 2 };
        }

        function hexDistance(q, r) {
            return (Math.abs(q) + Math.abs(q + r) + Math.abs(r)) / 2;
        }

        function generateGrid() {
            hexGrid = [];
            for (let q = -MAP_RADIUS; q <= MAP_RADIUS; q++) {
                let r1 = Math.max(-MAP_RADIUS, -q - MAP_RADIUS);
                let r2 = Math.min(MAP_RADIUS, -q + MAP_RADIUS);
                for (let r = r1; r <= r2; r++) {
                    hexGrid.push({ q, r });
                }
            }
        }

        function isOpposite(d1, d2) {
            return (d1.q + d2.q === 0) && (d1.r + d2.r === 0);
        }

        function changeDirection(newDir) {
            if (!isOpposite(direction, newDir)) {
                nextDirection = newDir;
            }
        }

        // --- GAMEPAD LOGIC ---
        function updateGamepad() {
            const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
            const gp = gamepads[0]; 
            if (!gp) return;

            const x = gp.axes[0];
            const y = gp.axes[1];
            if (Math.abs(x) < 0.2 && Math.abs(y) < 0.2) return;

            let angle = Math.atan2(y, x) * (180 / Math.PI);
            let newDir = null;

            if (angle > -30 && angle <= 30) newDir = DIRECTIONS.E;
            else if (angle > 30 && angle <= 90) newDir = DIRECTIONS.SE;
            else if (angle > 90 && angle <= 150) newDir = DIRECTIONS.SW;
            else if (angle > 150 || angle <= -150) newDir = DIRECTIONS.W;
            else if (angle > -150 && angle <= -90) newDir = DIRECTIONS.NW;
            else if (angle > -90 && angle <= -30) newDir = DIRECTIONS.NE;

            if (newDir) changeDirection(newDir);
        }

        // --- LOOP PRINCIPAL ---
        function initGame() {
            resizeGame(); // Asegurar tamaño correcto al inicio
            generateGrid();
            snake = [{ q: 0, r: 0 }, { q: -1, r: 0 }, { q: -2, r: 0 }];
            direction = DIRECTIONS.E;
            nextDirection = DIRECTIONS.E;
            score = 0;
            scoreEl.innerText = score;
            gameRunning = true;
            document.getElementById('game-over').style.display = 'none';
            spawnFood();
            requestAnimationFrame(gameLoop);
        }

        function gameLoop(timestamp) {
            if (!gameRunning) return;
            updateGamepad();
            if (timestamp - lastTime > SPEED) {
                update();
                draw();
                lastTime = timestamp;
            }
            requestAnimationFrame(gameLoop);
        }

        function spawnFood() {
            let valid = false;
            while (!valid) {
                const randomIndex = Math.floor(Math.random() * hexGrid.length);
                let pos = hexGrid[randomIndex];
                let collision = false;
                for (let segment of snake) {
                    if (segment.q === pos.q && segment.r === pos.r) collision = true;
                }
                if (!collision) {
                    food = pos;
                    valid = true;
                }
            }
        }

        function update() {
            direction = nextDirection;
            const head = snake[0];
            const newHead = { q: head.q + direction.q, r: head.r + direction.r };

            if (hexDistance(newHead.q, newHead.r) > MAP_RADIUS) return endGame();
            for (let segment of snake) {
                if (segment.q === newHead.q && segment.r === newHead.r) return endGame();
            }

            snake.unshift(newHead);
            if (food && newHead.q === food.q && newHead.r === food.r) {
                score += 10;
                scoreEl.innerText = score;
                spawnFood();
            } else {
                snake.pop();
            }
        }

        function endGame() {
            gameRunning = false;
            document.getElementById('final-score').innerText = score;
            document.getElementById('game-over').style.display = 'block';
        }

        function resetGame() {
            initGame();
        }

        // --- DIBUJO ---
        function drawHexagon(ctx, x, y, size, color, stroke = true) {
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle_rad = (Math.PI / 180) * (60 * i - 30);
                const px = x + size * Math.cos(angle_rad);
                const py = y + size * Math.sin(angle_rad);
                if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.fillStyle = color;
            ctx.fill();
            if (stroke) {
                ctx.strokeStyle = COLORS.border;
                ctx.lineWidth = 1;
                ctx.stroke();
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            for (let hex of hexGrid) {
                const pos = hexToPixel(hex.q, hex.r);
                const dist = hexDistance(hex.q, hex.r);
                let color = COLORS.outer;
                if (dist === 0) color = COLORS.center;
                else if (dist <= 3) color = COLORS.ring1;
                else if (dist <= 6) color = COLORS.ring2;
                drawHexagon(ctx, pos.x, pos.y, HEX_SIZE, color);
            }

            if (food) {
                const fPos = hexToPixel(food.q, food.r);
                drawHexagon(ctx, fPos.x, fPos.y, HEX_SIZE * 0.8, COLORS.food, false);
            }

            for (let i = 0; i < snake.length; i++) {
                const s = snake[i];
                const sPos = hexToPixel(s.q, s.r);
                drawHexagon(ctx, sPos.x, sPos.y, HEX_SIZE * 0.95, i===0?COLORS.snakeHead:COLORS.snakeBody, false);
            }
        }

        // --- INPUTS ---
        window.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            let newDir = null;
            switch(key) {
                case 'q': case '7': newDir = DIRECTIONS.NW; break;
                case 'w': case '9': newDir = DIRECTIONS.NE; break;
                case 'd': case '6': case 'arrowright': newDir = DIRECTIONS.E; break;
                case 'x': case '3': newDir = DIRECTIONS.SE; break;
                case 'z': case '1': newDir = DIRECTIONS.SW; break;
                case 'a': case '4': case 'arrowleft': newDir = DIRECTIONS.W; break;
            }
            if (newDir) changeDirection(newDir);
        });

        // Botones Táctiles
        const touchBtns = document.querySelectorAll('.dpad-btn');
        touchBtns.forEach(btn => {
            const handleInput = (e) => {
                if(e.cancelable) e.preventDefault(); // Importante para evitar zoom/scroll
                const key = btn.dataset.key;
                let newDir = null;
                if(key === 'q') newDir = DIRECTIONS.NW;
                if(key === 'w') newDir = DIRECTIONS.NE;
                if(key === 'd') newDir = DIRECTIONS.E;
                if(key === 'x') newDir = DIRECTIONS.SE;
                if(key === 'z') newDir = DIRECTIONS.SW;
                if(key === 'a') newDir = DIRECTIONS.W;
                if (newDir) changeDirection(newDir);
            };
            
            btn.addEventListener('mousedown', handleInput);
            btn.addEventListener('touchstart', handleInput, {passive: false});
        });

        // Iniciar
        initGame();

    </script>
</body>
</html>